{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Electricity Trading API","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Specification for Electricity Trading API.</p>"},{"location":"#overview","title":"Overview","text":"<p>The Frequenz API offers a robust set of operations for managing electricity trading orders within Gridpools. A Gridpool is an aggregation of multiple microgrids into a virtual power pool, designed to ensure the balancing of electricity supply and demand in real time.</p>"},{"location":"#objective","title":"Objective","text":"<p>The primary aim of this API is to streamline the process of electricity trading within balancing groups. A balancing group is a network configuration that includes multiple electricity producers and consumers. Grid stability relies on maintaining a balance between supply and demand within these groups. Participants causing imbalances can face financial penalties. Using this API, individual participants can trade electricity efficiently, ensuring they meet both their operational needs and financial objectives, while also contributing to the overall grid stability.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Order Placement: Facilitates the creation, modification, and deletion of trading orders.</li> <li>Real-Time Matching: Enables real-time order matching within the Gridpool.</li> <li>Order Tracking: Allows users to track the status of their orders, providing transparency and control.</li> <li>Public Order Book: Provides access to a list of public orders for market visibility and analysis.</li> </ul>"},{"location":"#target-audience","title":"Target Audience","text":"<p>This API is primarily designed for application developers in the energy sector who focus on electricity trading, grid management, and related services. While the API covers complex energy market operations, its design aims to be as developer-friendly as possible, requiring no specialized knowledge in energy systems.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Electricity Trading API","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You need to make sure you have the <code>git submodules</code> updated:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"CONTRIBUTING/#running-protolint","title":"Running protolint","text":"<p>To make sure some common mistakes are avoided and to ensure a consistent style it is recommended to run <code>protolint</code>. After you installed <code>protolint</code>, just run:</p> <pre><code>protolint lint proto\n</code></pre>"},{"location":"CONTRIBUTING/#python-setup","title":"Python setup","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>This will also generate the Python files from the <code>proto/</code> files and leave them in <code>py/</code>, so you can inspect them.</p> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#upgrading-dependencies","title":"Upgrading dependencies","text":"<p>If you want to update the dependency <code>frequenz-api-common</code>, then you need to:</p> <ol> <li>Update the submodule <code>frequenz-api-common</code></li> <li>Update the version of the <code>frequenz-api-common</code> package in <code>pyproject.toml</code></li> </ol> <p>The version of <code>frequenz-api-common</code> used in both places mentioned above should be the same.</p> <p>Here is an example of upgrading the <code>frequenz-api-common</code> dependency to version <code>v0.2.0</code>: <pre><code>ver=\"0.2.0\"\n\ncd submodules/frequenz-api-common\ngit remote update\ngit checkout v${ver}\ncd -\n\nsed s/\"frequenz-api-common == [0-9]\\.[0-9]\\.[0-9]\"/\"frequenz-api-common == ${ver}\"/g -i pyproject.toml\n</code></pre></p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Protobuf API Reference</li> <li>Python API Reference</li> <li>Contributing</li> </ul>"},{"location":"protobuf-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>electricity_trading<ul> <li>v1<ul> <li>electricity_trading.proto</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/","title":"Protocol Documentation","text":""},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>frequenz/api/electricity_trading/v1/electricity_trading.proto</p> <ul> <li>CancelAllGridpoolOrdersRequest</li> <li>CancelAllGridpoolOrdersResponse</li> <li>CancelGridpoolOrderRequest</li> <li>CancelGridpoolOrderResponse</li> <li>CreateGridpoolOrderRequest</li> <li>CreateGridpoolOrderResponse</li> <li>GetGridpoolOrderRequest</li> <li>GetGridpoolOrderResponse</li> <li>GridpoolOrderFilter</li> <li>ListGridpoolOrdersRequest</li> <li>ListGridpoolOrdersResponse</li> <li>ListPublicTradesRequest</li> <li>ListPublicTradesResponse</li> <li>Order</li> <li>OrderDetail</li> <li>OrderDetail.StateDetail</li> <li>PublicTrade</li> <li>PublicTradeFilter</li> <li>ReceiveGridpoolOrdersStreamRequest</li> <li>ReceiveGridpoolOrdersStreamResponse</li> <li>ReceivePublicTradesStreamRequest</li> <li>ReceivePublicTradesStreamResponse</li> <li>UpdateGridpoolOrderRequest</li> <li>UpdateGridpoolOrderRequest.UpdateOrder</li> <li> <p>UpdateGridpoolOrderResponse</p> </li> <li> <p>MarketSide</p> </li> <li>OrderDetail.StateDetail.MarketActor</li> <li>OrderDetail.StateDetail.StateReason</li> <li>OrderExecutionOption</li> <li>OrderState</li> <li> <p>OrderType</p> </li> <li> <p>ElectricityTradingService</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#frequenzapielectricity_tradingv1electricity_tradingproto","title":"frequenz/api/electricity_trading/v1/electricity_trading.proto","text":""},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#cancelallgridpoolordersrequest","title":"CancelAllGridpoolOrdersRequest","text":"<p>Request to cancel all currently open orders for a given Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the gridpool containing the orders to be cancelled. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#cancelallgridpoolordersresponse","title":"CancelAllGridpoolOrdersResponse","text":"<p>Response to canceling all currently open orders for a given Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the gridpool to cancel the orders for. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#cancelgridpoolorderrequest","title":"CancelGridpoolOrderRequest","text":"<p>Request to cancel an existing order for a given Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the gridpool the order belongs to. order_id uint64 ID of the order to be cancelled. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#cancelgridpoolorderresponse","title":"CancelGridpoolOrderResponse","text":"<p>Response from canceling an existing order for a given Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the gridpool the order belongs to. order_detail OrderDetail Details of the cancelled order. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#creategridpoolorderrequest","title":"CreateGridpoolOrderRequest","text":"<p>Represents a request to create a new order for a specific Gridpool.</p> <p>A Gridpool is a collection of microgrids that can span multiple delivery areas. It's important to note that when submitting an order for a Gridpool, you must group microgrids by their respective delivery areas. This means you should submit separate orders for each delivery area within the Gridpool. Failing to do so could lead to inaccuracies in the bidding process and may not fully represent the capabilities or constraints of the microgrids in different delivery areas. However, in most countries only one delivery area exists, exceptions are countries like e.g. Australia, Germany and the US.</p> <p>Caution</p> <p>If a Gridpool contains microgrids in both Delivery Area A and Delivery  Area B, you should submit one order for Delivery Area A and another for  Delivery Area B, specifying the details for each.</p> Field Type Label Description gridpool_id uint64 Unique identifier for the Gridpool to which the bid belongs. order Order The details of the order being placed. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#creategridpoolorderresponse","title":"CreateGridpoolOrderResponse","text":"<p>Represents the server's response after a new order has been successfully created for a specific Gridpool.</p> <p>This response provides essential details about the newly created order, such as the unique order ID and the state of the order. By receiving this response, users can be sure that their order has been placed successfully for the designated Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the gridpool the order belongs to. order_detail OrderDetail Details of the newly created order. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#getgridpoolorderrequest","title":"GetGridpoolOrderRequest","text":"<p>Request to retrieve a single order for a given Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the gridpool containing the order to be retrieved. order_id uint64 ID of the order to be retrieved. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#getgridpoolorderresponse","title":"GetGridpoolOrderResponse","text":"<p>Response from requesting order details for a specific order.</p> Field Type Label Description gridpool_id uint64 ID of the gridpool containing the retrieved order. order_detail OrderDetail Details of the retrieved order. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#gridpoolorderfilter","title":"GridpoolOrderFilter","text":"<p>Parameters for filtering Gridpool orders.</p> <p>Note</p> <p>Multiple filters can be used in combination to narrow down the returned results. For example, you can apply both state and side filters simultaneously to list only the open orders on the buy side of the market.</p> Field Type Label Description states OrderState repeated Optional filter for order state. side MarketSide optional Optional filter for order side. delivery_period frequenz.api.common.v1.grid.DeliveryPeriod Optional filter for delivery period. delivery_area frequenz.api.common.v1.grid.DeliveryArea Optional filter for delivery area. tag string optional Optional filters the listed orders by their associated tag. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#listgridpoolordersrequest","title":"ListGridpoolOrdersRequest","text":"<p>Request to retrieve a list of orders for a specific Gridpool.</p> Field Type Label Description gridpool_id uint64 The Gridpool to retrieve the orders for. filter GridpoolOrderFilter Optional Gridpool orders filter. pagination_params frequenz.api.common.v1.pagination.PaginationParams Pagination parameters. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#listgridpoolordersresponse","title":"ListGridpoolOrdersResponse","text":"<p>Response from listing orders for a given Gridpool.</p> Field Type Label Description order_detail_lists OrderDetail repeated List of all listed orders with their details. pagination_info frequenz.api.common.v1.pagination.PaginationInfo Metadata for pagination, including token for next page to retrieve. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#listpublictradesrequest","title":"ListPublicTradesRequest","text":"<p>Request to list all historic public trades with optional filters. This method allows for querying historical data, useful for various analytics tasks.</p> Field Type Label Description filter PublicTradeFilter Optional filter to narrow down the list of trades. pagination_params frequenz.api.common.v1.pagination.PaginationParams Pagination parameters. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#listpublictradesresponse","title":"ListPublicTradesResponse","text":"<p>ListPublicTradesResponse is a message that contains a list of historic public trades. This dataset is vital for tasks such as training machine learning models, backtesting trading strategies, and conducting market analysis.</p> Field Type Label Description public_trade_lists PublicTrade repeated List of all public trades that met the specified filtering criteria. pagination_info frequenz.api.common.v1.pagination.PaginationInfo Metadata for pagination, including token for next page to retrieve. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#order","title":"Order","text":"<p>Represents an order in the electricity market.</p> Field Type Label Description delivery_area frequenz.api.common.v1.grid.DeliveryArea The delivery area where the contract is to be delivered. The representation of the delivery area may vary by jurisdiction. delivery_period frequenz.api.common.v1.grid.DeliveryPeriod The delivery period for the contract, specified as a start and end timestamp in UTC. It represents the period during which the contract is expected to be fulfilled. type OrderType The type of order, such as LIMIT, STOP_LIMIT, ICEBERG etc. This determines how the order is to be executed in the market. side MarketSide Indicates if the order is on the Buy or Sell side of the market. price frequenz.api.common.v1.market.Price The limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order. quantity frequenz.api.common.v1.market.Energy The quantity of the contract being traded, specified in MWh. stop_price frequenz.api.common.v1.market.Price Optional; Applicable for STOP_LIMIT orders. This is the stop price that triggers the limit order. peak_price_delta frequenz.api.common.v1.market.Price Optional; Applicable for ICEBERG orders. This is the price difference between the peak price and the limit price. display_quantity frequenz.api.common.v1.market.Energy Optional; Applicable for ICEBERG orders. This is the quantity of the order to be displayed in the order book. execution_option OrderExecutionOption optional Optional execution options such as All or None, Fill or Kill, etc. valid_until google.protobuf.Timestamp Optional; Do not use if ExecutionOption is set to FOK or IOC. This is an optional UTC timestamp defining the time after which the order should be cancelled if not filled. payload google.protobuf.Struct Optional user-defined payload individual to a specific order. This can be any data that needs to be associated with the order. <p>The field can store e.g. JSON objects containing details involved in the order. This feature can simplify application development by eliminating the need for complicated state management to remember the specifics of each order.</p> <p>By embedding this \"state\" within the order itself, you can include specifics like which microgrids consume or provide how much power. This makes it easier to manage complex orders and can simplify the logic required in applications.</p> <p>Example JSON payload: { \"microgrids\": [ { \"microgrid_id\": \"1\", \"mwh\": 1.0 }, { \"microgrid_id\": \"2\", \"mwh\": 0.5 } ] }</p> <p>In this example, if the order is exectuted, these microgrids might consume the electricity mentioned in the example JSON payload. | | tag | string | optional | Optional user-defined tag to group related orders. |</p> <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#orderdetail","title":"OrderDetail","text":"<p>Represents an order with full details, including its ID, state and associated UTC timestamps.</p> Field Type Label Description order_id uint64 Unique identifier of the order. order Order The details of the order. state_detail OrderDetail.StateDetail Details of the order's current state. open_quantity frequenz.api.common.v1.market.Energy Remaining open quantity for this order. filled_quantity frequenz.api.common.v1.market.Energy Filled quantity for this order. create_time google.protobuf.Timestamp UTC Timestamp when the order was created. modification_time google.protobuf.Timestamp UTC Timestamp of the last update to the order. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#orderdetailstatedetail","title":"OrderDetail.StateDetail","text":"<p>Inner message providing details about the current state of the order.</p> Field Type Label Description state OrderState Current state of the order. state_reason OrderDetail.StateDetail.StateReason Reason for the current state. market_actor OrderDetail.StateDetail.MarketActor Actor responsible for the current state. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#publictrade","title":"PublicTrade","text":"<p>Represents a public trade in the market.</p> <p>Each <code>trade</code> within this response message represents two orders that were previously active in the public order book and matched, along with its key attributes and final state.</p> <p>Note</p> <p>A <code>trade</code> refers to the event where a buy order and a sell order are  matched and executed, representing the final state of those orders.  While \"executed\" or \"filled\" orders pertain to the completion of  individual buy or sell orders, a \"trade\" signifies the actual  transaction where both types of orders (buy and sell) are successfully  matched and carried out. This distinction is crucial, as a trade is the  broader occurrence resulting from the execution of both sides of the  transaction, although post-trade processes like settlement may still  follow. The term 'trade' is sometimes used interchangeably with  'executed order' in trading platforms, but it technically encompasses  the completion of both a buy and a sell order.</p> Field Type Label Description id uint64 ID of the trade from the public order book. buy_delivery_area frequenz.api.common.v1.grid.DeliveryArea Delivery area code of the buy side. sell_delivery_area frequenz.api.common.v1.grid.DeliveryArea Delivery area code of the sell side. delivery_period frequenz.api.common.v1.grid.DeliveryPeriod The delivery period for the contract. modification_time google.protobuf.Timestamp UTC Timestamp of the last order update or matching. price frequenz.api.common.v1.market.Price The limit price at which the contract is to be traded. quantity frequenz.api.common.v1.market.Energy The quantity of the contract being traded in MWh. state OrderState Final state of the trade. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#publictradefilter","title":"PublicTradeFilter","text":"<p>Parameters for filtering historic public trades.</p> <p>Note</p> <p>In some countries or regions the buy and sell delivery area can be different. This is usually referred to as cross bid.</p> <p>Note</p> <p>Multiple filters can be used in combination to narrow down the returned results. For example, you can apply both state and delivery area filters simultaneously to list only the trades that occurred at a certain time in a specific delivery area.</p> Field Type Label Description states OrderState repeated If set, only trades in this state are returned. delivery_period frequenz.api.common.v1.grid.DeliveryPeriod Optional; If set, only trades with this delivery period are returned. buy_delivery_area frequenz.api.common.v1.grid.DeliveryArea Optional; If set, only trades in this buy delivery area are returned. sell_delivery_area frequenz.api.common.v1.grid.DeliveryArea Optional; If set, only trades in this sell delivery area are returned. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#receivegridpoolordersstreamrequest","title":"ReceiveGridpoolOrdersStreamRequest","text":"<p>Subscribe to Gridpool order stream. This method provides real-time updates on Gridpool orders, making it useful for dynamic analytics and real-time decision-making.</p> Field Type Label Description gridpool_id uint64 The gridpool to retrieve the orders for. filter GridpoolOrderFilter Optional public orders filter. <p>!!! Important Note Regarding \"DeliveryPeriod Filter\" Ensure that the specified DeliveryPeriod is set for a future timeframe. If a past or present period is selected, the stream will automatically close and return no entries. |</p> <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#receivegridpoolordersstreamresponse","title":"ReceiveGridpoolOrdersStreamResponse","text":"<p>Response to a subscription request for a stream of Gridpool orders. Real-time information on gridpool orders is pushed through this response.</p> Field Type Label Description order_detail OrderDetail Order detail response. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#receivepublictradesstreamrequest","title":"ReceivePublicTradesStreamRequest","text":"<p>Subscribe to the stream of public trades. This method provides real-time updates on newly executed public trades, making it useful dynamic analytics and real-time decision-making.</p> Field Type Label Description filter PublicTradeFilter Optional filter to specify which trades should be included in the stream. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#receivepublictradesstreamresponse","title":"ReceivePublicTradesStreamResponse","text":"<p>Response to a subscription request for a stream of public trades. Real-time information on public trades is pushed through this response.</p> Field Type Label Description public_trade PublicTrade The public trade that has been executed and is being broadcasted in real-time. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#updategridpoolorderrequest","title":"UpdateGridpoolOrderRequest","text":"<p>Request to update an existing order for a given Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the Gridpool the order belongs to. order_id uint64 The order identifier update_mask google.protobuf.FieldMask Field mask specifying which fields should be updated update_order_fields UpdateGridpoolOrderRequest.UpdateOrder The fields that can be updated <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#updategridpoolorderrequestupdateorder","title":"UpdateGridpoolOrderRequest.UpdateOrder","text":"<p>Represents the order properties that can be updated after an order has been placed. At least one of the optional fields must be set for an update to take place.</p> Field Type Label Description price frequenz.api.common.v1.market.Price Optional; The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order. quantity frequenz.api.common.v1.market.Energy Optional; The updated quantity of the contract being traded, specified in MWh. stop_price frequenz.api.common.v1.market.Price Optional; Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order. peak_price_delta frequenz.api.common.v1.market.Price Optional; Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price. display_quantity frequenz.api.common.v1.market.Energy Optional; Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book. execution_option OrderExecutionOption Optional; Updated execution options such as All or None, Fill or Kill, etc. valid_until google.protobuf.Timestamp Optional; This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC. payload google.protobuf.Struct Optional; Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order. tag string optional Optional; Updated user-defined tag to group related orders. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#updategridpoolorderresponse","title":"UpdateGridpoolOrderResponse","text":"<p>Response from updating an existing order for a given Gridpool.</p> Field Type Label Description gridpool_id uint64 ID of the Gridpool the order belongs to. order_detail OrderDetail Details of the updated order. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#marketside","title":"MarketSide","text":"<p>Enum for the side of the market that the order is on.</p> Name Number Description MARKET_SIDE_UNSPECIFIED 0 UNSPECIFIED: The side of the market has not been set. MARKET_SIDE_BUY 1 BUY: Order to purchase electricity. This is referred to as a 'bid' in the order book. MARKET_SIDE_SELL 2 SELL: Order to sell electricity. This is referred to as an 'ask' or 'offer' in the order book. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#orderdetailstatedetailmarketactor","title":"OrderDetail.StateDetail.MarketActor","text":"<p>Enum describing the actor responsible for an order state change.</p> Name Number Description MARKET_ACTOR_UNSPECIFIED 0 MARKET_ACTOR_USER 1 The user was the actor. MARKET_ACTOR_MARKET_OPERATOR 2 The market operator was the actor. MARKET_ACTOR_SYSTEM 3 The system was the actor. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#orderdetailstatedetailstatereason","title":"OrderDetail.StateDetail.StateReason","text":"<p>Enum describing the action that led to the state change.</p> Name Number Description STATE_REASON_UNSPECIFIED 0 STATE_REASON_ADD 1 The order was added. STATE_REASON_MODIFY 2 The order was modified. STATE_REASON_DELETE 3 The order was deleted. STATE_REASON_DEACTIVATE 4 The order was deactivated. STATE_REASON_REJECT 5 The order was rejected. STATE_REASON_FULL_EXECUTION 6 The order was fully executed. STATE_REASON_PARTIAL_EXECUTION 7 The order was partially executed. STATE_REASON_ICEBERG_SLICE_ADD 8 An iceberg slice was added. STATE_REASON_VALIDATION_FAIL 9 The order failed validation. STATE_REASON_UNKNOWN_STATE 10 The state of the order is unknown. STATE_REASON_QUOTE_ADD 11 A quote was added. STATE_REASON_QUOTE_FULL_EXECUTION 12 A quote was fully executed. STATE_REASON_QUOTE_PARTIAL_EXECUTION 13 A quote was partially executed. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#orderexecutionoption","title":"OrderExecutionOption","text":"<p>OrderExecutionOption defines specific behavior for the execution of an order. These options provide control on how an order is handled in the market.</p> Name Number Description ORDER_EXECUTION_OPTION_UNSPECIFIED 0 UNSPECIFIED: The order execution option has not been set. ORDER_EXECUTION_OPTION_NONE 1 Order remains open until it's fully fulfilled, cancelled by the client, <code>valid_until</code> timestamp is reached, or the end of the trading session. ORDER_EXECUTION_OPTION_AON 2 All or None: Order must be executed in its entirety, or not executed at all. ORDER_EXECUTION_OPTION_FOK 3 Fill or Kill: Order must be executed immediately in its entirety, or not at all. ORDER_EXECUTION_OPTION_IOC 4 Immediate or Cancel: Any portion of an order that cannot be filled immediately will be cancelled. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#orderstate","title":"OrderState","text":"<p>Enum for the state of an order.</p> Name Number Description ORDER_STATE_UNSPECIFIED 0 UNSPECIFIED: The order state is not known. This is usually the default state of a newly created order object before any operations have been applied. ORDER_STATE_PENDING 1 PENDING: The order has been sent to the marketplace but has not yet been confirmed. This can be due to awaiting validation or system processing. ORDER_STATE_ACTIVE 2 ACTIVE: The order has been confirmed and is open in the market. It may be unfilled or partially filled. ORDER_STATE_FILLED 3 FILLED: The order has been completely filled and there are no remaining quantities on the order. ORDER_STATE_CANCELED 4 CANCELED: The order has been cancelled. This can occur due to a cancellation request by the market participant, system, or market operator. ORDER_STATE_CANCEL_REQUESTED 5 CANCEL_REQUESTED: A cancellation request for the order has been submitted but the order is not yet removed from the order book. ORDER_STATE_CANCEL_REJECTED 6 CANCEL_REJECTED: The order cancellation request was rejected, likely due to it having already been filled or expired. ORDER_STATE_EXPIRED 7 EXPIRED: The order has not been filled within the defined duration and has expired. ORDER_STATE_FAILED 8 FAILED: The order submission failed and was unable to be placed on the order book, usually due to a validation error or system issue. ORDER_STATE_HIBERNATE 9 HIBERNATE: The order has been entered into the system but is not currently exposed to the market. This could be due to certain conditions not yet being met. ORDER_STATE_RECALL 10 RECALL: The order has been recalled. This could be due to a system issue or a request from the market participant or market operator. ORDER_STATE_RECALL_REQUESTED 11 RECALL_REQUESTED: A recall request for the order has been submitted but the order is not yet removed from the order book. ORDER_STATE_RECALL_REJECTED 12 RECALL_REJECTED: The order recall request was rejected, likely due to it having already been filled or expired. ORDER_STATE_APPROVAL 13 APPROVAL: The order has been sent for approval. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#ordertype","title":"OrderType","text":"<p>Enum for the order types that can be specified for an order.</p> Name Number Description ORDER_TYPE_UNSPECIFIED 0 UNSPECIFIED: The order type has not been set. ORDER_TYPE_LIMIT 1 LIMIT: Order to buy or sell at a specific price or better. It remains active until it is filled, cancelled, or expired. ORDER_TYPE_STOP_LIMIT 2 STOP_LIMIT: An order that will be executed at a specified price, or better, after a given stop price has been reached. ORDER_TYPE_ICEBERG 3 ICEBERG: A large order divided into smaller lots to hide the actual order quantity. Only the visible part of the order is shown in the order book. ORDER_TYPE_BLOCK 4 BLOCK: (Not yet supported) User defined block order, generally a large quantity order filled all at once. ORDER_TYPE_BALANCE 5 BALANCE: (Not yet supported) Balance order aims to balance supply and demand, usually at a specific location or within a system. ORDER_TYPE_PREARRANGED 6 PRE: (Not yet supported) On exchange prearranged trade, a trade that has been privately negotiated and then submitted to the exchange. ORDER_TYPE_PRIVATE 7 PRIVATE: (Not yet supported) Private and confidential trade, not visible in the public order book and has no market impact. <p></p>"},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#electricitytradingservice","title":"ElectricityTradingService","text":"<p>Service providing operations related to order management.</p> Method Name Request Type Response Type Description CreateGridpoolOrder CreateGridpoolOrderRequest CreateGridpoolOrderResponse Creates a new order for a given Gridpool. UpdateGridpoolOrder UpdateGridpoolOrderRequest UpdateGridpoolOrderResponse Updates an existing order for a given Gridpool. CancelGridpoolOrder CancelGridpoolOrderRequest CancelGridpoolOrderResponse Cancels an existing order for a given Gridpool. CancelAllGridpoolOrders CancelAllGridpoolOrdersRequest CancelAllGridpoolOrdersResponse Cancels all open orders for a given Gridpool. GetGridpoolOrder GetGridpoolOrderRequest GetGridpoolOrderResponse Fetches the details of a specific order for a given Gridpool. ListGridpoolOrders ListGridpoolOrdersRequest ListGridpoolOrdersResponse Lists all the orders for a given Gridpool. ReceiveGridpoolOrdersStream ReceiveGridpoolOrdersStreamRequest ReceiveGridpoolOrdersStreamResponse stream Stream order updates for a given Gridpool. ListPublicTrades ListPublicTradesRequest ListPublicTradesResponse Lists all historic public trades. ReceivePublicTradesStream ReceivePublicTradesStreamRequest ReceivePublicTradesStreamResponse stream Stream all historic public trades."},{"location":"protobuf-reference/frequenz/api/electricity_trading/v1/electricity_trading/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"python-reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>api<ul> <li>electricity_trading<ul> <li>v1<ul> <li>electricity_trading_pb2</li> <li>electricity_trading_pb2_grpc</li> </ul> </li> </ul> </li> </ul> </li> <li>client<ul> <li>electricity_trading</li> </ul> </li> </ul> </li> </ul>"},{"location":"python-reference/frequenz/api/electricity_trading/","title":"Index","text":""},{"location":"python-reference/frequenz/api/electricity_trading/#frequenz.api.electricity_trading","title":"frequenz.api.electricity_trading","text":"<p>Frequenz gRPC API for electricity trading.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/","title":"Index","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/#frequenz.api.electricity_trading.v1","title":"frequenz.api.electricity_trading.v1","text":"<p>Frequenz gRPC API for electricity trading.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/","title":"electricity_trading_pb2","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2","text":"<p>Generated protocol buffer code.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.MARKET_SIDE_BUY","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.MARKET_SIDE_BUY  <code>module-attribute</code>","text":"<pre><code>MARKET_SIDE_BUY: ValueType\n</code></pre> <p>BUY: Order to purchase electricity. This is referred to as a 'bid' in the order book.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.MARKET_SIDE_SELL","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.MARKET_SIDE_SELL  <code>module-attribute</code>","text":"<pre><code>MARKET_SIDE_SELL: ValueType\n</code></pre> <p>SELL: Order to sell electricity. This is referred to as an 'ask' or 'offer' in the order book.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.MARKET_SIDE_UNSPECIFIED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.MARKET_SIDE_UNSPECIFIED  <code>module-attribute</code>","text":"<pre><code>MARKET_SIDE_UNSPECIFIED: ValueType\n</code></pre> <p>UNSPECIFIED: The side of the market has not been set.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_AON","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_AON  <code>module-attribute</code>","text":"<pre><code>ORDER_EXECUTION_OPTION_AON: ValueType\n</code></pre> <p>All or None: Order must be executed in its entirety, or not executed at all.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_FOK","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_FOK  <code>module-attribute</code>","text":"<pre><code>ORDER_EXECUTION_OPTION_FOK: ValueType\n</code></pre> <p>Fill or Kill: Order must be executed immediately in its entirety, or not at all.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_IOC","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_IOC  <code>module-attribute</code>","text":"<pre><code>ORDER_EXECUTION_OPTION_IOC: ValueType\n</code></pre> <p>Immediate or Cancel: Any portion of an order that cannot be filled immediately will be cancelled.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_NONE","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_NONE  <code>module-attribute</code>","text":"<pre><code>ORDER_EXECUTION_OPTION_NONE: ValueType\n</code></pre> <p>Order remains open until it's fully fulfilled, cancelled by the client, <code>valid_until</code> timestamp is reached, or the end of the trading session.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_UNSPECIFIED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_EXECUTION_OPTION_UNSPECIFIED  <code>module-attribute</code>","text":"<pre><code>ORDER_EXECUTION_OPTION_UNSPECIFIED: ValueType\n</code></pre> <p>UNSPECIFIED: The order execution option has not been set.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_ACTIVE","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_ACTIVE  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_ACTIVE: ValueType\n</code></pre> <p>ACTIVE: The order has been confirmed and is open in the market. It may be unfilled or partially filled.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_APPROVAL","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_APPROVAL  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_APPROVAL: ValueType\n</code></pre> <p>APPROVAL: The order has been sent for approval.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_CANCELED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_CANCELED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_CANCELED: ValueType\n</code></pre> <p>CANCELED: The order has been cancelled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_CANCEL_REJECTED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_CANCEL_REJECTED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_CANCEL_REJECTED: ValueType\n</code></pre> <p>CANCEL_REJECTED: The order cancellation request was rejected, likely due to it having already been filled or expired.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_CANCEL_REQUESTED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_CANCEL_REQUESTED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_CANCEL_REQUESTED: ValueType\n</code></pre> <p>CANCEL_REQUESTED: A cancellation request for the order has been submitted but the order is not yet removed from the order book.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_EXPIRED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_EXPIRED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_EXPIRED: ValueType\n</code></pre> <p>EXPIRED: The order has not been filled within the defined duration and has expired.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_FAILED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_FAILED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_FAILED: ValueType\n</code></pre> <p>FAILED: The order submission failed and was unable to be placed on the order book, usually due to a validation error or system issue.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_FILLED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_FILLED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_FILLED: ValueType\n</code></pre> <p>FILLED: The order has been completely filled and there are no remaining quantities on the order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_HIBERNATE","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_HIBERNATE  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_HIBERNATE: ValueType\n</code></pre> <p>HIBERNATE: The order has been entered into the system but is not currently exposed to the market. This could be due to certain conditions not yet being met.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_PENDING","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_PENDING  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_PENDING: ValueType\n</code></pre> <p>PENDING: The order has been sent to the marketplace but has not yet been confirmed. This can be due to awaiting validation or system processing.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_RECALL","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_RECALL  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_RECALL: ValueType\n</code></pre> <p>RECALL: The order has been recalled. This could be due to a system issue or a request from the market participant or market operator.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_RECALL_REJECTED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_RECALL_REJECTED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_RECALL_REJECTED: ValueType\n</code></pre> <p>RECALL_REJECTED: The order recall request was rejected, likely due to it having already been filled or expired.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_RECALL_REQUESTED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_RECALL_REQUESTED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_RECALL_REQUESTED: ValueType\n</code></pre> <p>RECALL_REQUESTED: A recall request for the order has been submitted but the order is not yet removed from the order book.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_UNSPECIFIED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_STATE_UNSPECIFIED  <code>module-attribute</code>","text":"<pre><code>ORDER_STATE_UNSPECIFIED: ValueType\n</code></pre> <p>UNSPECIFIED: The order state is not known. This is usually the default state of a newly created order object before any operations have been applied.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_BALANCE","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_BALANCE  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_BALANCE: ValueType\n</code></pre> <p>BALANCE: (Not yet supported) Balance order aims to balance supply and demand, usually at a specific location or within a system.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_BLOCK","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_BLOCK  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_BLOCK: ValueType\n</code></pre> <p>BLOCK: (Not yet supported) User defined block order, generally a large quantity order filled all at once.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_ICEBERG","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_ICEBERG  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_ICEBERG: ValueType\n</code></pre> <p>ICEBERG: A large order divided into smaller lots to hide the actual order quantity. Only the visible part of the order is shown in the order book.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_LIMIT","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_LIMIT  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_LIMIT: ValueType\n</code></pre> <p>LIMIT: Order to buy or sell at a specific price or better. It remains active until it is filled, cancelled, or expired.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_PREARRANGED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_PREARRANGED  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_PREARRANGED: ValueType\n</code></pre> <p>PRE: (Not yet supported) On exchange prearranged trade, a trade that has been privately negotiated and then submitted to the exchange.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_PRIVATE","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_PRIVATE  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_PRIVATE: ValueType\n</code></pre> <p>PRIVATE: (Not yet supported) Private and confidential trade, not visible in the public order book and has no market impact.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_STOP_LIMIT","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_STOP_LIMIT  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_STOP_LIMIT: ValueType\n</code></pre> <p>STOP_LIMIT: An order that will be executed at a specified price, or better, after a given stop price has been reached.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_UNSPECIFIED","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ORDER_TYPE_UNSPECIFIED  <code>module-attribute</code>","text":"<pre><code>ORDER_TYPE_UNSPECIFIED: ValueType\n</code></pre> <p>UNSPECIFIED: The order type has not been set.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersRequest","text":"<p>             Bases: <code>Message</code></p> <p>Request to cancel all currently open orders for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersRequest.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the gridpool containing the orders to be cancelled.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersResponse","text":"<p>             Bases: <code>Message</code></p> <p>Response to canceling all currently open orders for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelAllGridpoolOrdersResponse.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the gridpool to cancel the orders for.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderRequest","text":"<p>             Bases: <code>Message</code></p> <p>Request to cancel an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderRequest.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the gridpool the order belongs to.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderRequest.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: int\n</code></pre> <p>ID of the order to be cancelled.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderResponse","text":"<p>             Bases: <code>Message</code></p> <p>Response from canceling an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderResponse.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the gridpool the order belongs to.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CancelGridpoolOrderResponse.order_detail","title":"order_detail  <code>property</code>","text":"<pre><code>order_detail: global___OrderDetail\n</code></pre> <p>Details of the cancelled order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderRequest","text":"<p>             Bases: <code>Message</code></p> <p>Represents a request to create a new order for a specific Gridpool.</p> <p>A Gridpool is a collection of microgrids that can span multiple delivery areas. It's important to note that when submitting an order for a Gridpool, you must group microgrids by their respective delivery areas. This means you should submit separate orders for each delivery area within the Gridpool. Failing to do so could lead to inaccuracies in the bidding process and may not fully represent the capabilities or constraints of the microgrids in different delivery areas. However, in most countries only one delivery area exists, exceptions are countries like e.g. Australia, Germany and the US.</p> <p>Caution</p> <p>If a Gridpool contains microgrids in both Delivery Area A and Delivery  Area B, you should submit one order for Delivery Area A and another for  Delivery Area B, specifying the details for each.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderRequest.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>Unique identifier for the Gridpool to which the bid belongs.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderRequest.order","title":"order  <code>property</code>","text":"<pre><code>order: global___Order\n</code></pre> <p>The details of the order being placed.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderResponse","text":"<p>             Bases: <code>Message</code></p> <p>Represents the server's response after a new order has been successfully created for a specific Gridpool.</p> <p>This response provides essential details about the newly created order, such as the unique order ID and the state of the order. By receiving this response, users can be sure that their order has been placed successfully for the designated Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderResponse.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the gridpool the order belongs to.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.CreateGridpoolOrderResponse.order_detail","title":"order_detail  <code>property</code>","text":"<pre><code>order_detail: global___OrderDetail\n</code></pre> <p>Details of the newly created order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderRequest","text":"<p>             Bases: <code>Message</code></p> <p>Request to retrieve a single order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderRequest.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the gridpool containing the order to be retrieved.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderRequest.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: int\n</code></pre> <p>ID of the order to be retrieved.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderResponse","text":"<p>             Bases: <code>Message</code></p> <p>Response from requesting order details for a specific order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderResponse.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the gridpool containing the retrieved order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GetGridpoolOrderResponse.order_detail","title":"order_detail  <code>property</code>","text":"<pre><code>order_detail: global___OrderDetail\n</code></pre> <p>Details of the retrieved order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for filtering Gridpool orders.</p> <p>Note</p> <p>Multiple filters can be used in combination to narrow down the returned results. For example, you can apply both state and side filters simultaneously to list only the open orders on the buy side of the market.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter.delivery_area","title":"delivery_area  <code>property</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>Optional filter for delivery area.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter.delivery_period","title":"delivery_period  <code>property</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>Optional filter for delivery period.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: ValueType\n</code></pre> <p>Optional filter for order side.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter.states","title":"states  <code>property</code>","text":"<pre><code>states: RepeatedScalarFieldContainer[ValueType]\n</code></pre> <p>Optional filter for order state.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.GridpoolOrderFilter.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str\n</code></pre> <p>Optional filters the listed orders by their associated tag.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersRequest","text":"<p>             Bases: <code>Message</code></p> <p>Request to retrieve a list of orders for a specific Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersRequest.filter","title":"filter  <code>property</code>","text":"<pre><code>filter: global___GridpoolOrderFilter\n</code></pre> <p>Optional Gridpool orders filter.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersRequest.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>The Gridpool to retrieve the orders for.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersRequest.pagination_params","title":"pagination_params  <code>property</code>","text":"<pre><code>pagination_params: PaginationParams\n</code></pre> <p>Pagination parameters.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersResponse","text":"<p>             Bases: <code>Message</code></p> <p>Response from listing orders for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersResponse.order_detail_lists","title":"order_detail_lists  <code>property</code>","text":"<pre><code>order_detail_lists: RepeatedCompositeFieldContainer[\n    global___OrderDetail\n]\n</code></pre> <p>List of all listed orders with their details.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListGridpoolOrdersResponse.pagination_info","title":"pagination_info  <code>property</code>","text":"<pre><code>pagination_info: PaginationInfo\n</code></pre> <p>Metadata for pagination, including token for next page to retrieve.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesRequest","text":"<p>             Bases: <code>Message</code></p> <p>Request to list all historic public trades with optional filters. This method allows for querying historical data, useful for various analytics tasks.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesRequest.filter","title":"filter  <code>property</code>","text":"<pre><code>filter: global___PublicTradeFilter\n</code></pre> <p>Optional filter to narrow down the list of trades.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesRequest.pagination_params","title":"pagination_params  <code>property</code>","text":"<pre><code>pagination_params: PaginationParams\n</code></pre> <p>Pagination parameters.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesResponse","text":"<p>             Bases: <code>Message</code></p> <p>ListPublicTradesResponse is a message that contains a list of historic public trades. This dataset is vital for tasks such as training machine learning models, backtesting trading strategies, and conducting market analysis.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesResponse.pagination_info","title":"pagination_info  <code>property</code>","text":"<pre><code>pagination_info: PaginationInfo\n</code></pre> <p>Metadata for pagination, including token for next page to retrieve.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ListPublicTradesResponse.public_trade_lists","title":"public_trade_lists  <code>property</code>","text":"<pre><code>public_trade_lists: RepeatedCompositeFieldContainer[\n    global___PublicTrade\n]\n</code></pre> <p>List of all public trades that met the specified filtering criteria.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.MarketSide","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.MarketSide","text":"<p>             Bases: <code>_MarketSide</code></p> <p>Enum for the side of the market that the order is on.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order","text":"<p>             Bases: <code>Message</code></p> <p>Represents an order in the electricity market.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.delivery_area","title":"delivery_area  <code>property</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>The delivery area where the contract is to be delivered. The representation of the delivery area may vary by jurisdiction.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.delivery_period","title":"delivery_period  <code>property</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract, specified as a start and end timestamp in UTC. It represents the period during which the contract is expected to be fulfilled.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.display_quantity","title":"display_quantity  <code>property</code>","text":"<pre><code>display_quantity: Energy\n</code></pre> <p>Optional; Applicable for ICEBERG orders. This is the quantity of the order to be displayed in the order book.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.execution_option","title":"execution_option  <code>instance-attribute</code>","text":"<pre><code>execution_option: ValueType\n</code></pre> <p>Optional execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.payload","title":"payload  <code>property</code>","text":"<pre><code>payload: Struct\n</code></pre> <p>Optional user-defined payload individual to a specific order. This can be any data that needs to be associated with the order.</p> <p>The field can store e.g. JSON objects containing details involved in the order. This feature can simplify application development by eliminating the need for complicated state management to remember the specifics of each order.</p> <p>By embedding this \"state\" within the order itself, you can include specifics like which microgrids consume or provide how much power. This makes it easier to manage complex orders and can simplify the logic required in applications.</p> <p>Example JSON payload: {   \"microgrids\": [     {       \"microgrid_id\": \"1\",       \"mwh\": 1.0     },     {       \"microgrid_id\": \"2\",       \"mwh\": 0.5     }   ] }</p> <p>In this example, if the order is exectuted, these microgrids might consume the electricity mentioned in the example JSON payload.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.peak_price_delta","title":"peak_price_delta  <code>property</code>","text":"<pre><code>peak_price_delta: Price\n</code></pre> <p>Optional; Applicable for ICEBERG orders. This is the price difference between the peak price and the limit price.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.price","title":"price  <code>property</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.quantity","title":"quantity  <code>property</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded, specified in MWh.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: ValueType\n</code></pre> <p>Indicates if the order is on the Buy or Sell side of the market.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.stop_price","title":"stop_price  <code>property</code>","text":"<pre><code>stop_price: Price\n</code></pre> <p>Optional; Applicable for STOP_LIMIT orders. This is the stop price that triggers the limit order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str\n</code></pre> <p>Optional user-defined tag to group related orders.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: ValueType\n</code></pre> <p>The type of order, such as LIMIT, STOP_LIMIT, ICEBERG etc. This determines how the order is to be executed in the market.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.Order.valid_until","title":"valid_until  <code>property</code>","text":"<pre><code>valid_until: Timestamp\n</code></pre> <p>Optional; Do not use if ExecutionOption is set to FOK or IOC. This is an optional UTC timestamp defining the time after which the order should be cancelled if not filled.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail","text":"<p>             Bases: <code>Message</code></p> <p>Represents an order with full details, including its ID, state and associated UTC timestamps.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.create_time","title":"create_time  <code>property</code>","text":"<pre><code>create_time: Timestamp\n</code></pre> <p>UTC Timestamp when the order was created.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.filled_quantity","title":"filled_quantity  <code>property</code>","text":"<pre><code>filled_quantity: Energy\n</code></pre> <p>Filled quantity for this order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.modification_time","title":"modification_time  <code>property</code>","text":"<pre><code>modification_time: Timestamp\n</code></pre> <p>UTC Timestamp of the last update to the order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.open_quantity","title":"open_quantity  <code>property</code>","text":"<pre><code>open_quantity: Energy\n</code></pre> <p>Remaining open quantity for this order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.order","title":"order  <code>property</code>","text":"<pre><code>order: global___Order\n</code></pre> <p>The details of the order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: int\n</code></pre> <p>Unique identifier of the order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.state_detail","title":"state_detail  <code>property</code>","text":"<pre><code>state_detail: StateDetail\n</code></pre> <p>Details of the order's current state.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderDetail.StateDetail","title":"StateDetail","text":"<p>             Bases: <code>Message</code></p> <p>Inner message providing details about the current state of the order.</p> Attributes\u00a4 MARKET_ACTOR_MARKET_OPERATOR <code>instance-attribute</code> \u00a4 <pre><code>MARKET_ACTOR_MARKET_OPERATOR: ValueType\n</code></pre> <p>The market operator was the actor.</p> MARKET_ACTOR_SYSTEM <code>instance-attribute</code> \u00a4 <pre><code>MARKET_ACTOR_SYSTEM: ValueType\n</code></pre> <p>The system was the actor.</p> MARKET_ACTOR_USER <code>instance-attribute</code> \u00a4 <pre><code>MARKET_ACTOR_USER: ValueType\n</code></pre> <p>The user was the actor.</p> STATE_REASON_ADD <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_ADD: ValueType\n</code></pre> <p>The order was added.</p> STATE_REASON_DEACTIVATE <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_DEACTIVATE: ValueType\n</code></pre> <p>The order was deactivated.</p> STATE_REASON_DELETE <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_DELETE: ValueType\n</code></pre> <p>The order was deleted.</p> STATE_REASON_FULL_EXECUTION <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_FULL_EXECUTION: ValueType\n</code></pre> <p>The order was fully executed.</p> STATE_REASON_ICEBERG_SLICE_ADD <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_ICEBERG_SLICE_ADD: ValueType\n</code></pre> <p>An iceberg slice was added.</p> STATE_REASON_MODIFY <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_MODIFY: ValueType\n</code></pre> <p>The order was modified.</p> STATE_REASON_PARTIAL_EXECUTION <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_PARTIAL_EXECUTION: ValueType\n</code></pre> <p>The order was partially executed.</p> STATE_REASON_QUOTE_ADD <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_QUOTE_ADD: ValueType\n</code></pre> <p>A quote was added.</p> STATE_REASON_QUOTE_FULL_EXECUTION <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_QUOTE_FULL_EXECUTION: ValueType\n</code></pre> <p>A quote was fully executed.</p> STATE_REASON_QUOTE_PARTIAL_EXECUTION <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_QUOTE_PARTIAL_EXECUTION: ValueType\n</code></pre> <p>A quote was partially executed.</p> STATE_REASON_REJECT <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_REJECT: ValueType\n</code></pre> <p>The order was rejected.</p> STATE_REASON_UNKNOWN_STATE <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_UNKNOWN_STATE: ValueType\n</code></pre> <p>The state of the order is unknown.</p> STATE_REASON_VALIDATION_FAIL <code>instance-attribute</code> \u00a4 <pre><code>STATE_REASON_VALIDATION_FAIL: ValueType\n</code></pre> <p>The order failed validation.</p> market_actor <code>instance-attribute</code> \u00a4 <pre><code>market_actor: ValueType\n</code></pre> <p>Actor responsible for the current state.</p> state <code>instance-attribute</code> \u00a4 <pre><code>state: ValueType\n</code></pre> <p>Current state of the order.</p> state_reason <code>instance-attribute</code> \u00a4 <pre><code>state_reason: ValueType\n</code></pre> <p>Reason for the current state.</p> Classes\u00a4 MarketActor \u00a4 <p>             Bases: <code>_MarketActor</code></p> <p>Enum describing the actor responsible for an order state change.</p> StateReason \u00a4 <p>             Bases: <code>_StateReason</code></p> <p>Enum describing the action that led to the state change.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderExecutionOption","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderExecutionOption","text":"<p>             Bases: <code>_OrderExecutionOption</code></p> <p>OrderExecutionOption defines specific behavior for the execution of an order. These options provide control on how an order is handled in the market.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2.py</code> <pre><code>_globals['_UPDATEGRIDPOOLORDERREQUEST_UPDATEORDER']._serialized_end=4966\n_globals['_UPDATEGRIDPOOLORDERRESPONSE']._serialized_start=4969\n_globals['_UPDATEGRIDPOOLORDERRESPONSE']._serialized_end=5111\n_globals['_CANCELGRIDPOOLORDERREQUEST']._serialized_start=5113\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderState","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderState","text":"<p>             Bases: <code>_OrderState</code></p> <p>Enum for the state of an order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderType","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.OrderType","text":"<p>             Bases: <code>_OrderType</code></p> <p>Enum for the order types that can be specified for an order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade","text":"<p>             Bases: <code>Message</code></p> <p>Represents a public trade in the market.</p> <p>Each <code>trade</code> within this response message represents two orders that were previously active in the public order book and matched, along with its key attributes and final state.</p> <p>Note</p> <p>A <code>trade</code> refers to the event where a buy order and a sell order are  matched and executed, representing the final state of those orders.  While \"executed\" or \"filled\" orders pertain to the completion of  individual buy or sell orders, a \"trade\" signifies the actual  transaction where both types of orders (buy and sell) are successfully  matched and carried out. This distinction is crucial, as a trade is the  broader occurrence resulting from the execution of both sides of the  transaction, although post-trade processes like settlement may still  follow. The term 'trade' is sometimes used interchangeably with  'executed order' in trading platforms, but it technically encompasses  the completion of both a buy and a sell order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.buy_delivery_area","title":"buy_delivery_area  <code>property</code>","text":"<pre><code>buy_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the buy side.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.delivery_period","title":"delivery_period  <code>property</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>ID of the trade from the public order book.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.modification_time","title":"modification_time  <code>property</code>","text":"<pre><code>modification_time: Timestamp\n</code></pre> <p>UTC Timestamp of the last order update or matching.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.price","title":"price  <code>property</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.quantity","title":"quantity  <code>property</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded in MWh.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.sell_delivery_area","title":"sell_delivery_area  <code>property</code>","text":"<pre><code>sell_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the sell side.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTrade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: ValueType\n</code></pre> <p>Final state of the trade.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTradeFilter","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTradeFilter","text":"<p>             Bases: <code>Message</code></p> <p>Parameters for filtering historic public trades.</p> <p>Note</p> <p>In some countries or regions the buy and sell delivery area can be different. This is usually referred to as cross bid.</p> <p>Note</p> <p>Multiple filters can be used in combination to narrow down the returned results. For example, you can apply both state and delivery area filters simultaneously to list only the trades that occurred at a certain time in a specific delivery area.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTradeFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTradeFilter.buy_delivery_area","title":"buy_delivery_area  <code>property</code>","text":"<pre><code>buy_delivery_area: DeliveryArea\n</code></pre> <p>Optional; If set, only trades in this buy delivery area are returned.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTradeFilter.delivery_period","title":"delivery_period  <code>property</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>Optional; If set, only trades with this delivery period are returned.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTradeFilter.sell_delivery_area","title":"sell_delivery_area  <code>property</code>","text":"<pre><code>sell_delivery_area: DeliveryArea\n</code></pre> <p>Optional; If set, only trades in this sell delivery area are returned.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.PublicTradeFilter.states","title":"states  <code>property</code>","text":"<pre><code>states: RepeatedScalarFieldContainer[ValueType]\n</code></pre> <p>If set, only trades in this state are returned.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest","text":"<p>             Bases: <code>Message</code></p> <p>Subscribe to Gridpool order stream. This method provides real-time updates on Gridpool orders, making it useful for dynamic analytics and real-time decision-making.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest.filter","title":"filter  <code>property</code>","text":"<pre><code>filter: global___GridpoolOrderFilter\n</code></pre> <p>Optional public orders filter.</p> <p>DeliveryPeriod Filter</p> <p>Ensure that the specified DeliveryPeriod is set for a future timeframe. If a past or present period is selected, the stream will automatically close and return no entries.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>The gridpool to retrieve the orders for.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse","text":"<p>             Bases: <code>Message</code></p> <p>Response to a subscription request for a stream of Gridpool orders. Real-time information on gridpool orders is pushed through this response.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse.order_detail","title":"order_detail  <code>property</code>","text":"<pre><code>order_detail: global___OrderDetail\n</code></pre> <p>Order detail response.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamRequest","text":"<p>             Bases: <code>Message</code></p> <p>Subscribe to the stream of public trades. This method provides real-time updates on newly executed public trades, making it useful dynamic analytics and real-time decision-making.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamRequest.filter","title":"filter  <code>property</code>","text":"<pre><code>filter: global___PublicTradeFilter\n</code></pre> <p>Optional filter to specify which trades should be included in the stream.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamResponse","text":"<p>             Bases: <code>Message</code></p> <p>Response to a subscription request for a stream of public trades. Real-time information on public trades is pushed through this response.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.ReceivePublicTradesStreamResponse.public_trade","title":"public_trade  <code>property</code>","text":"<pre><code>public_trade: global___PublicTrade\n</code></pre> <p>The public trade that has been executed and is being broadcasted in real-time.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest","text":"<p>             Bases: <code>Message</code></p> <p>Request to update an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the Gridpool the order belongs to.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: int\n</code></pre> <p>The order identifier</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest.update_mask","title":"update_mask  <code>property</code>","text":"<pre><code>update_mask: FieldMask\n</code></pre> <p>Field mask specifying which fields should be updated</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest.update_order_fields","title":"update_order_fields  <code>property</code>","text":"<pre><code>update_order_fields: UpdateOrder\n</code></pre> <p>The fields that can be updated</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder","title":"UpdateOrder","text":"<p>             Bases: <code>Message</code></p> <p>Represents the order properties that can be updated after an order has been placed. At least one of the optional fields must be set for an update to take place.</p> Attributes\u00a4 display_quantity <code>property</code> \u00a4 <pre><code>display_quantity: Energy\n</code></pre> <p>Optional; Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p> execution_option <code>instance-attribute</code> \u00a4 <pre><code>execution_option: ValueType\n</code></pre> <p>Optional; Updated execution options such as All or None, Fill or Kill, etc.</p> payload <code>property</code> \u00a4 <pre><code>payload: Struct\n</code></pre> <p>Optional; Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p> peak_price_delta <code>property</code> \u00a4 <pre><code>peak_price_delta: Price\n</code></pre> <p>Optional; Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p> price <code>property</code> \u00a4 <pre><code>price: Price\n</code></pre> <p>Optional; The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p> quantity <code>property</code> \u00a4 <pre><code>quantity: Energy\n</code></pre> <p>Optional; The updated quantity of the contract being traded, specified in MWh.</p> stop_price <code>property</code> \u00a4 <pre><code>stop_price: Price\n</code></pre> <p>Optional; Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p> tag <code>instance-attribute</code> \u00a4 <pre><code>tag: str\n</code></pre> <p>Optional; Updated user-defined tag to group related orders.</p> valid_until <code>property</code> \u00a4 <pre><code>valid_until: Timestamp\n</code></pre> <p>Optional; This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderResponse","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderResponse","text":"<p>             Bases: <code>Message</code></p> <p>Response from updating an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderResponse-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderResponse.gridpool_id","title":"gridpool_id  <code>instance-attribute</code>","text":"<pre><code>gridpool_id: int\n</code></pre> <p>ID of the Gridpool the order belongs to.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2/#frequenz.api.electricity_trading.v1.electricity_trading_pb2.UpdateGridpoolOrderResponse.order_detail","title":"order_detail  <code>property</code>","text":"<pre><code>order_detail: global___OrderDetail\n</code></pre> <p>Details of the updated order.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/","title":"electricity_trading_pb2_grpc","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc","text":"<p>Client and server classes corresponding to protobuf-defined services.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingService","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingService","text":"<p>             Bases: <code>object</code></p> <p>Service providing operations related to order management.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>class ElectricityTradingService(object):\n    \"\"\"Service providing operations related to order management.\n    \"\"\"\n\n    @staticmethod\n    def CreateGridpoolOrder(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CreateGridpoolOrder',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CreateGridpoolOrderRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CreateGridpoolOrderResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def UpdateGridpoolOrder(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/UpdateGridpoolOrder',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.UpdateGridpoolOrderRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.UpdateGridpoolOrderResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def CancelGridpoolOrder(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelGridpoolOrder',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelGridpoolOrderRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelGridpoolOrderResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def CancelAllGridpoolOrders(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelAllGridpoolOrders',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelAllGridpoolOrdersRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelAllGridpoolOrdersResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def GetGridpoolOrder(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/GetGridpoolOrder',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.GetGridpoolOrderRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.GetGridpoolOrderResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListGridpoolOrders(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListGridpoolOrders',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListGridpoolOrdersRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListGridpoolOrdersResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ReceiveGridpoolOrdersStream(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceiveGridpoolOrdersStream',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceiveGridpoolOrdersStreamRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceiveGridpoolOrdersStreamResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ListPublicTrades(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_unary(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListPublicTrades',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListPublicTradesRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListPublicTradesResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n\n    @staticmethod\n    def ReceivePublicTradesStream(request,\n            target,\n            options=(),\n            channel_credentials=None,\n            call_credentials=None,\n            insecure=False,\n            compression=None,\n            wait_for_ready=None,\n            timeout=None,\n            metadata=None):\n        return grpc.experimental.unary_stream(request, target, '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceivePublicTradesStream',\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceivePublicTradesStreamRequest.SerializeToString,\n            frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceivePublicTradesStreamResponse.FromString,\n            options, channel_credentials,\n            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub","text":"<p>Service providing operations related to order management.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\ndef CancelGridpoolOrder(self, request, context):\n    \"\"\"Cancels an existing order for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\ndef CancelAllGridpoolOrders(self, request, context):\n    \"\"\"Cancels all open orders for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\ndef GetGridpoolOrder(self, request, context):\n    \"\"\"Fetches the details of a specific order for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\ndef ListGridpoolOrders(self, request, context):\n    \"\"\"Lists all the orders for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\ndef ReceiveGridpoolOrdersStream(self, request, context):\n    \"\"\"Stream order updates for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\ndef ListPublicTrades(self, request, context):\n    \"\"\"Lists all historic public trades.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n\ndef ReceivePublicTradesStream(self, request, context):\n    \"\"\"Stream all historic public trades.\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.CancelAllGridpoolOrders","title":"CancelAllGridpoolOrders  <code>instance-attribute</code>","text":"<pre><code>CancelAllGridpoolOrders: UnaryUnaryMultiCallable[\n    CancelAllGridpoolOrdersRequest,\n    CancelAllGridpoolOrdersResponse,\n]\n</code></pre> <p>Cancels all open orders for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.CancelGridpoolOrder","title":"CancelGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>CancelGridpoolOrder: UnaryUnaryMultiCallable[\n    CancelGridpoolOrderRequest, CancelGridpoolOrderResponse\n]\n</code></pre> <p>Cancels an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.CreateGridpoolOrder","title":"CreateGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>CreateGridpoolOrder: UnaryUnaryMultiCallable[\n    CreateGridpoolOrderRequest, CreateGridpoolOrderResponse\n]\n</code></pre> <p>Creates a new order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.GetGridpoolOrder","title":"GetGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>GetGridpoolOrder: UnaryUnaryMultiCallable[\n    GetGridpoolOrderRequest, GetGridpoolOrderResponse\n]\n</code></pre> <p>Fetches the details of a specific order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.ListGridpoolOrders","title":"ListGridpoolOrders  <code>instance-attribute</code>","text":"<pre><code>ListGridpoolOrders: UnaryUnaryMultiCallable[\n    ListGridpoolOrdersRequest, ListGridpoolOrdersResponse\n]\n</code></pre> <p>Lists all the orders for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.ListPublicTrades","title":"ListPublicTrades  <code>instance-attribute</code>","text":"<pre><code>ListPublicTrades: UnaryUnaryMultiCallable[\n    ListPublicTradesRequest, ListPublicTradesResponse\n]\n</code></pre> <p>Lists all historic public trades.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.ReceiveGridpoolOrdersStream","title":"ReceiveGridpoolOrdersStream  <code>instance-attribute</code>","text":"<pre><code>ReceiveGridpoolOrdersStream: UnaryStreamMultiCallable[\n    ReceiveGridpoolOrdersStreamRequest,\n    ReceiveGridpoolOrdersStreamResponse,\n]\n</code></pre> <p>Stream order updates for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.ReceivePublicTradesStream","title":"ReceivePublicTradesStream  <code>instance-attribute</code>","text":"<pre><code>ReceivePublicTradesStream: UnaryStreamMultiCallable[\n    ReceivePublicTradesStreamRequest,\n    ReceivePublicTradesStreamResponse,\n]\n</code></pre> <p>Stream all historic public trades.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceAsyncStub.UpdateGridpoolOrder","title":"UpdateGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>UpdateGridpoolOrder: UnaryUnaryMultiCallable[\n    UpdateGridpoolOrderRequest, UpdateGridpoolOrderResponse\n]\n</code></pre> <p>Updates an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer","text":"<p>             Bases: <code>object</code></p> <p>Service providing operations related to order management.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>class ElectricityTradingServiceServicer(object):\n    \"\"\"Service providing operations related to order management.\n    \"\"\"\n\n    def CreateGridpoolOrder(self, request, context):\n        \"\"\"Creates a new order for a given Gridpool.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def UpdateGridpoolOrder(self, request, context):\n        \"\"\"Updates an existing order for a given Gridpool.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def CancelGridpoolOrder(self, request, context):\n        \"\"\"Cancels an existing order for a given Gridpool.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def CancelAllGridpoolOrders(self, request, context):\n        \"\"\"Cancels all open orders for a given Gridpool.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def GetGridpoolOrder(self, request, context):\n        \"\"\"Fetches the details of a specific order for a given Gridpool.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ListGridpoolOrders(self, request, context):\n        \"\"\"Lists all the orders for a given Gridpool.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ReceiveGridpoolOrdersStream(self, request, context):\n        \"\"\"Stream order updates for a given Gridpool.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ListPublicTrades(self, request, context):\n        \"\"\"Lists all historic public trades.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n\n    def ReceivePublicTradesStream(self, request, context):\n        \"\"\"Stream all historic public trades.\n        \"\"\"\n        context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n        context.set_details('Method not implemented!')\n        raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.CancelAllGridpoolOrders","title":"CancelAllGridpoolOrders","text":"<pre><code>CancelAllGridpoolOrders(\n    request: CancelAllGridpoolOrdersRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    CancelAllGridpoolOrdersResponse,\n    Awaitable[CancelAllGridpoolOrdersResponse],\n]\n</code></pre> <p>Cancels all open orders for a given Gridpool.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def CancelAllGridpoolOrders(self, request, context):\n    \"\"\"Cancels all open orders for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.CancelGridpoolOrder","title":"CancelGridpoolOrder","text":"<pre><code>CancelGridpoolOrder(\n    request: CancelGridpoolOrderRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    CancelGridpoolOrderResponse,\n    Awaitable[CancelGridpoolOrderResponse],\n]\n</code></pre> <p>Cancels an existing order for a given Gridpool.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def CancelGridpoolOrder(self, request, context):\n    \"\"\"Cancels an existing order for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.CreateGridpoolOrder","title":"CreateGridpoolOrder","text":"<pre><code>CreateGridpoolOrder(\n    request: CreateGridpoolOrderRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    CreateGridpoolOrderResponse,\n    Awaitable[CreateGridpoolOrderResponse],\n]\n</code></pre> <p>Creates a new order for a given Gridpool.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def CreateGridpoolOrder(self, request, context):\n    \"\"\"Creates a new order for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.GetGridpoolOrder","title":"GetGridpoolOrder","text":"<pre><code>GetGridpoolOrder(\n    request: GetGridpoolOrderRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    GetGridpoolOrderResponse,\n    Awaitable[GetGridpoolOrderResponse],\n]\n</code></pre> <p>Fetches the details of a specific order for a given Gridpool.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def GetGridpoolOrder(self, request, context):\n    \"\"\"Fetches the details of a specific order for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.ListGridpoolOrders","title":"ListGridpoolOrders","text":"<pre><code>ListGridpoolOrders(\n    request: ListGridpoolOrdersRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    ListGridpoolOrdersResponse,\n    Awaitable[ListGridpoolOrdersResponse],\n]\n</code></pre> <p>Lists all the orders for a given Gridpool.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def ListGridpoolOrders(self, request, context):\n    \"\"\"Lists all the orders for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.ListPublicTrades","title":"ListPublicTrades","text":"<pre><code>ListPublicTrades(\n    request: ListPublicTradesRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    ListPublicTradesResponse,\n    Awaitable[ListPublicTradesResponse],\n]\n</code></pre> <p>Lists all historic public trades.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def ListPublicTrades(self, request, context):\n    \"\"\"Lists all historic public trades.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.ReceiveGridpoolOrdersStream","title":"ReceiveGridpoolOrdersStream","text":"<pre><code>ReceiveGridpoolOrdersStream(\n    request: ReceiveGridpoolOrdersStreamRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    Iterator[ReceiveGridpoolOrdersStreamResponse],\n    AsyncIterator[ReceiveGridpoolOrdersStreamResponse],\n]\n</code></pre> <p>Stream order updates for a given Gridpool.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def ReceiveGridpoolOrdersStream(self, request, context):\n    \"\"\"Stream order updates for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.ReceivePublicTradesStream","title":"ReceivePublicTradesStream","text":"<pre><code>ReceivePublicTradesStream(\n    request: ReceivePublicTradesStreamRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    Iterator[ReceivePublicTradesStreamResponse],\n    AsyncIterator[ReceivePublicTradesStreamResponse],\n]\n</code></pre> <p>Stream all historic public trades.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def ReceivePublicTradesStream(self, request, context):\n    \"\"\"Stream all historic public trades.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceServicer.UpdateGridpoolOrder","title":"UpdateGridpoolOrder","text":"<pre><code>UpdateGridpoolOrder(\n    request: UpdateGridpoolOrderRequest,\n    context: _ServicerContext,\n) -&gt; Union[\n    UpdateGridpoolOrderResponse,\n    Awaitable[UpdateGridpoolOrderResponse],\n]\n</code></pre> <p>Updates an existing order for a given Gridpool.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def UpdateGridpoolOrder(self, request, context):\n    \"\"\"Updates an existing order for a given Gridpool.\n    \"\"\"\n    context.set_code(grpc.StatusCode.UNIMPLEMENTED)\n    context.set_details('Method not implemented!')\n    raise NotImplementedError('Method not implemented!')\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub","title":"frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub","text":"<p>             Bases: <code>object</code></p> <p>Service providing operations related to order management.</p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>class ElectricityTradingServiceStub(object):\n    \"\"\"Service providing operations related to order management.\n    \"\"\"\n\n    def __init__(self, channel):\n        \"\"\"Constructor.\n\n        Args:\n            channel: A grpc.Channel.\n        \"\"\"\n        self.CreateGridpoolOrder = channel.unary_unary(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CreateGridpoolOrder',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CreateGridpoolOrderRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CreateGridpoolOrderResponse.FromString,\n                )\n        self.UpdateGridpoolOrder = channel.unary_unary(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/UpdateGridpoolOrder',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.UpdateGridpoolOrderRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.UpdateGridpoolOrderResponse.FromString,\n                )\n        self.CancelGridpoolOrder = channel.unary_unary(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelGridpoolOrder',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelGridpoolOrderRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelGridpoolOrderResponse.FromString,\n                )\n        self.CancelAllGridpoolOrders = channel.unary_unary(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelAllGridpoolOrders',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelAllGridpoolOrdersRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelAllGridpoolOrdersResponse.FromString,\n                )\n        self.GetGridpoolOrder = channel.unary_unary(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/GetGridpoolOrder',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.GetGridpoolOrderRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.GetGridpoolOrderResponse.FromString,\n                )\n        self.ListGridpoolOrders = channel.unary_unary(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListGridpoolOrders',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListGridpoolOrdersRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListGridpoolOrdersResponse.FromString,\n                )\n        self.ReceiveGridpoolOrdersStream = channel.unary_stream(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceiveGridpoolOrdersStream',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceiveGridpoolOrdersStreamRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceiveGridpoolOrdersStreamResponse.FromString,\n                )\n        self.ListPublicTrades = channel.unary_unary(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListPublicTrades',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListPublicTradesRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListPublicTradesResponse.FromString,\n                )\n        self.ReceivePublicTradesStream = channel.unary_stream(\n                '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceivePublicTradesStream',\n                request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceivePublicTradesStreamRequest.SerializeToString,\n                response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceivePublicTradesStreamResponse.FromString,\n                )\n</code></pre>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.CancelAllGridpoolOrders","title":"CancelAllGridpoolOrders  <code>instance-attribute</code>","text":"<pre><code>CancelAllGridpoolOrders: UnaryUnaryMultiCallable[\n    CancelAllGridpoolOrdersRequest,\n    CancelAllGridpoolOrdersResponse,\n] = unary_unary(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelAllGridpoolOrders\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Cancels all open orders for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.CancelGridpoolOrder","title":"CancelGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>CancelGridpoolOrder: UnaryUnaryMultiCallable[\n    CancelGridpoolOrderRequest, CancelGridpoolOrderResponse\n] = unary_unary(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelGridpoolOrder\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Cancels an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.CreateGridpoolOrder","title":"CreateGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>CreateGridpoolOrder: UnaryUnaryMultiCallable[\n    CreateGridpoolOrderRequest, CreateGridpoolOrderResponse\n] = unary_unary(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CreateGridpoolOrder\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Creates a new order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.GetGridpoolOrder","title":"GetGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>GetGridpoolOrder: UnaryUnaryMultiCallable[\n    GetGridpoolOrderRequest, GetGridpoolOrderResponse\n] = unary_unary(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/GetGridpoolOrder\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Fetches the details of a specific order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.ListGridpoolOrders","title":"ListGridpoolOrders  <code>instance-attribute</code>","text":"<pre><code>ListGridpoolOrders: UnaryUnaryMultiCallable[\n    ListGridpoolOrdersRequest, ListGridpoolOrdersResponse\n] = unary_unary(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListGridpoolOrders\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Lists all the orders for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.ListPublicTrades","title":"ListPublicTrades  <code>instance-attribute</code>","text":"<pre><code>ListPublicTrades: UnaryUnaryMultiCallable[\n    ListPublicTradesRequest, ListPublicTradesResponse\n] = unary_unary(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListPublicTrades\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Lists all historic public trades.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.ReceiveGridpoolOrdersStream","title":"ReceiveGridpoolOrdersStream  <code>instance-attribute</code>","text":"<pre><code>ReceiveGridpoolOrdersStream: UnaryStreamMultiCallable[\n    ReceiveGridpoolOrdersStreamRequest,\n    ReceiveGridpoolOrdersStreamResponse,\n] = unary_stream(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceiveGridpoolOrdersStream\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Stream order updates for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.ReceivePublicTradesStream","title":"ReceivePublicTradesStream  <code>instance-attribute</code>","text":"<pre><code>ReceivePublicTradesStream: UnaryStreamMultiCallable[\n    ReceivePublicTradesStreamRequest,\n    ReceivePublicTradesStreamResponse,\n] = unary_stream(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceivePublicTradesStream\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Stream all historic public trades.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.UpdateGridpoolOrder","title":"UpdateGridpoolOrder  <code>instance-attribute</code>","text":"<pre><code>UpdateGridpoolOrder: UnaryUnaryMultiCallable[\n    UpdateGridpoolOrderRequest, UpdateGridpoolOrderResponse\n] = unary_unary(\n    \"/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/UpdateGridpoolOrder\",\n    request_serializer=SerializeToString,\n    response_deserializer=FromString,\n)\n</code></pre> <p>Updates an existing order for a given Gridpool.</p>"},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc/#frequenz.api.electricity_trading.v1.electricity_trading_pb2_grpc.ElectricityTradingServiceStub.__init__","title":"__init__","text":"<pre><code>__init__(channel: Union[Channel, Channel]) -&gt; None\n</code></pre> <p>Constructor.</p> PARAMETER  DESCRIPTION <code>channel</code> <p>A grpc.Channel.</p> <p> TYPE: <code>Union[Channel, Channel]</code> </p> Source code in <code>frequenz/api/electricity_trading/v1/electricity_trading_pb2_grpc.py</code> <pre><code>def __init__(self, channel):\n    \"\"\"Constructor.\n\n    Args:\n        channel: A grpc.Channel.\n    \"\"\"\n    self.CreateGridpoolOrder = channel.unary_unary(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CreateGridpoolOrder',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CreateGridpoolOrderRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CreateGridpoolOrderResponse.FromString,\n            )\n    self.UpdateGridpoolOrder = channel.unary_unary(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/UpdateGridpoolOrder',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.UpdateGridpoolOrderRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.UpdateGridpoolOrderResponse.FromString,\n            )\n    self.CancelGridpoolOrder = channel.unary_unary(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelGridpoolOrder',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelGridpoolOrderRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelGridpoolOrderResponse.FromString,\n            )\n    self.CancelAllGridpoolOrders = channel.unary_unary(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/CancelAllGridpoolOrders',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelAllGridpoolOrdersRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.CancelAllGridpoolOrdersResponse.FromString,\n            )\n    self.GetGridpoolOrder = channel.unary_unary(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/GetGridpoolOrder',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.GetGridpoolOrderRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.GetGridpoolOrderResponse.FromString,\n            )\n    self.ListGridpoolOrders = channel.unary_unary(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListGridpoolOrders',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListGridpoolOrdersRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListGridpoolOrdersResponse.FromString,\n            )\n    self.ReceiveGridpoolOrdersStream = channel.unary_stream(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceiveGridpoolOrdersStream',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceiveGridpoolOrdersStreamRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceiveGridpoolOrdersStreamResponse.FromString,\n            )\n    self.ListPublicTrades = channel.unary_unary(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ListPublicTrades',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListPublicTradesRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ListPublicTradesResponse.FromString,\n            )\n    self.ReceivePublicTradesStream = channel.unary_stream(\n            '/frequenz.api.electricity_trading.electricity_trading.v1.ElectricityTradingService/ReceivePublicTradesStream',\n            request_serializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceivePublicTradesStreamRequest.SerializeToString,\n            response_deserializer=frequenz_dot_api_dot_electricity__trading_dot_v1_dot_electricity__trading__pb2.ReceivePublicTradesStreamResponse.FromString,\n            )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/","title":"electricity_trading","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading","title":"frequenz.client.electricity_trading","text":"<p>The Electricity Trading API client.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading-classes","title":"Classes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client","title":"frequenz.client.electricity_trading.Client","text":"<p>Electricity trading client.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>class Client:\n    \"\"\"Electricity trading client.\"\"\"\n\n    def __init__(self, grpc_channel: grpc.aio.Channel) -&gt; None:\n        \"\"\"Initialize the client.\n\n        Args:\n            grpc_channel: gRPC channel to use for communication with the API.\n        \"\"\"\n        self._stub = electricity_trading_pb2_grpc.ElectricityTradingServiceStub(\n            grpc_channel\n        )\n\n        self._gridpool_orders_streams: dict[\n            tuple[int, GridpoolOrderFilter],\n            GrpcStreamingHelper[\n                electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n            ],\n        ] = {}\n\n        self._public_trades_streams: dict[\n            PublicTradeFilter,\n            GrpcStreamingHelper[\n                electricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n            ],\n        ] = {}\n\n    async def stream_gridpool_orders(  # pylint: disable=too-many-arguments\n        self,\n        gridpool_id: int,\n        order_states: list[OrderState] | None = None,\n        market_side: MarketSide | None = None,\n        delivery_area: DeliveryArea | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        tag: str | None = None,\n    ) -&gt; Receiver[OrderDetail]:\n        \"\"\"\n        Stream gridpool orders.\n\n        Args:\n            gridpool_id: ID of the gridpool to stream orders for.\n            order_states: List of order states to filter for.\n            market_side: Market side to filter for.\n            delivery_area: Delivery area to filter for.\n            delivery_period: Delivery period to filter for.\n            tag: Tag to filter for.\n\n        Returns:\n            Async generator of orders.\n        \"\"\"\n        gridpool_filter = GridpoolOrderFilter(\n            states=order_states,\n            side=market_side,\n            delivery_area=delivery_area,\n            delivery_period=delivery_period,\n            tag=tag,\n        )\n\n        stream_key = (gridpool_id, gridpool_filter)\n\n        if stream_key not in self._gridpool_orders_streams:\n            self._gridpool_orders_streams[stream_key] = GrpcStreamingHelper(\n                f\"electricity-trading-{stream_key}\",\n                lambda: self._stub.ReceiveGridpoolOrdersStream(  # type: ignore\n                    electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\n                        gridpool_id=gridpool_id,\n                        filter=gridpool_filter.to_pb(),\n                    )\n                ),\n                lambda response: OrderDetail.from_pb(response.order_detail),\n            )\n        return self._gridpool_orders_streams[stream_key].new_receiver()\n\n    async def stream_public_trades(\n        self,\n        states: list[OrderState] | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        buy_delivery_area: DeliveryArea | None = None,\n        sell_delivery_area: DeliveryArea | None = None,\n    ) -&gt; Receiver[PublicTrade]:\n        \"\"\"\n        Stream public orders.\n\n        Args:\n            states: List of order states to filter for.\n            delivery_period: Delivery period to filter for.\n            buy_delivery_area: Buy delivery area to filter for.\n            sell_delivery_area: Sell delivery area to filter for.\n\n        Returns:\n            Async generator of orders.\n        \"\"\"\n        public_trade_filter = PublicTradeFilter(\n            states=states,\n            delivery_period=delivery_period,\n            buy_delivery_area=buy_delivery_area,\n            sell_delivery_area=sell_delivery_area,\n        )\n\n        if public_trade_filter not in self._public_trades_streams:\n            self._public_trades_streams[public_trade_filter] = GrpcStreamingHelper(\n                f\"electricity-trading-{public_trade_filter}\",\n                lambda: self._stub.ReceivePublicTradesStream(  # type: ignore\n                    electricity_trading_pb2.ReceivePublicTradesStreamRequest(\n                        filter=public_trade_filter.to_pb(),\n                    )\n                ),\n                lambda response: PublicTrade.from_pb(response.public_trade),\n            )\n        return self._public_trades_streams[public_trade_filter].new_receiver()\n\n    async def create_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n        self,\n        gridpool_id: int,\n        delivery_area: DeliveryArea,\n        delivery_period: DeliveryPeriod,\n        order_type: OrderType,\n        side: MarketSide,\n        price: Price,\n        quantity: Energy,\n        stop_price: Price | None = None,\n        peak_price_delta: Price | None = None,\n        display_quantity: Energy | None = None,\n        execution_option: OrderExecutionOption | None = None,\n        valid_until: datetime | None = None,\n        payload: dict[str, struct_pb2.Value] | None = None,\n        tag: str | None = None,\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Create a gridpool order.\n\n        Args:\n            gridpool_id: ID of the gridpool to create the order for.\n            delivery_area: Delivery area of the order.\n            delivery_period: Delivery period of the order.\n            order_type: Type of the order.\n            side: Side of the order.\n            price: Price of the order.\n            quantity: Quantity of the order.\n            stop_price: Stop price of the order.\n            peak_price_delta: Peak price delta of the order.\n            display_quantity: Display quantity of the order.\n            execution_option: Execution option of the order.\n            valid_until: Valid until of the order.\n            payload: Payload of the order.\n            tag: Tag of the order.\n\n        Returns:\n            The created order.\n        \"\"\"\n        order = Order(\n            delivery_area=delivery_area,\n            delivery_period=delivery_period,\n            type=order_type,\n            side=side,\n            price=price,\n            quantity=quantity,\n            stop_price=stop_price,\n            peak_price_delta=peak_price_delta,\n            display_quantity=display_quantity,\n            execution_option=execution_option,\n            valid_until=valid_until,\n            payload=payload,\n            tag=tag,\n        )\n\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\n            self._stub.CreateGridpoolOrder(\n                electricity_trading_pb2.CreateGridpoolOrderRequest(\n                    gridpool_id=gridpool_id,\n                    order=order.to_pb(),\n                )\n            ),\n        )\n\n        return OrderDetail.from_pb(response.order_detail)\n\n    async def update_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n        self,\n        gridpool_id: int,\n        order_id: int,\n        price: Price | None | _Sentinel = NO_VALUE,\n        quantity: Energy | None | _Sentinel = NO_VALUE,\n        stop_price: Price | None | _Sentinel = NO_VALUE,\n        peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n        display_quantity: Energy | None | _Sentinel = NO_VALUE,\n        execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n        valid_until: datetime | None | _Sentinel = NO_VALUE,\n        payload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\n        tag: str | None | _Sentinel = NO_VALUE,\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Update an existing order for a given Gridpool.\n\n        Args:\n            gridpool_id: ID of the Gridpool the order belongs to.\n            order_id: Order ID.\n            price: The updated limit price at which the contract is to be traded.\n                This is the maximum price for a BUY order or the minimum price for a SELL order.\n            quantity: The updated quantity of the contract being traded, specified in MWh.\n            stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n                triggers the limit order.\n            peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n                between the peak price and the limit price.\n            display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n                order to be displayed in the order book.\n            execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n            valid_until: This is an updated timestamp defining the time after which the order\n                should be cancelled if not filled. The timestamp is in UTC.\n            payload: Updated user-defined payload individual to a specific order. This can be any\n                data that the user wants to associate with the order.\n            tag: Updated user-defined tag to group related orders.\n\n        Returns:\n            The updated order.\n\n        Raises:\n            ValueError: If no fields to update are provided.\n        \"\"\"\n        params = {\n            \"price\": price,\n            \"quantity\": quantity,\n            \"stop_price\": stop_price,\n            \"peak_price_delta\": peak_price_delta,\n            \"display_quantity\": display_quantity,\n            \"execution_option\": execution_option,\n            \"valid_until\": valid_until,\n            \"payload\": payload,\n            \"tag\": tag,\n        }\n\n        if all(value is NO_VALUE for value in params.values()):\n            raise ValueError(\"At least one field to update must be provided.\")\n\n        paths = [param for param, value in params.items() if value is not NO_VALUE]\n\n        # Field mask specifying which fields should be updated\n        # This is used so that we can update parameters with None values\n        update_mask = field_mask_pb2.FieldMask(paths=paths)\n\n        update_order_fields = UpdateOrder(\n            price=None if price is NO_VALUE else price,\n            quantity=None if quantity is NO_VALUE else quantity,\n            stop_price=None if stop_price is NO_VALUE else stop_price,\n            peak_price_delta=None if peak_price_delta is NO_VALUE else peak_price_delta,\n            display_quantity=None if display_quantity is NO_VALUE else display_quantity,\n            execution_option=None if execution_option is NO_VALUE else execution_option,\n            valid_until=None if valid_until is NO_VALUE else valid_until,\n            payload=None if payload is NO_VALUE else payload,\n            tag=None if tag is NO_VALUE else tag,\n        )\n\n        response = await cast(\n            Awaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\n            self._stub.UpdateGridpoolOrder(\n                electricity_trading_pb2.UpdateGridpoolOrderRequest(\n                    gridpool_id=gridpool_id,\n                    order_id=order_id,\n                    update_order_fields=update_order_fields.to_pb(),\n                    update_mask=update_mask,\n                )\n            ),\n        )\n\n        return OrderDetail.from_pb(response.order_detail)\n\n    async def cancel_gridpool_order(\n        self, gridpool_id: int, order_id: int\n    ) -&gt; OrderDetail:\n        \"\"\"\n        Cancel a single order for a given Gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to cancel the order for.\n            order_id: The order to cancel.\n\n        Returns:\n            The cancelled order.\n        \"\"\"\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\n            self._stub.CancelGridpoolOrder(\n                electricity_trading_pb2.CancelGridpoolOrderRequest(\n                    gridpool_id=gridpool_id, order_id=order_id\n                )\n            ),\n        )\n\n        return OrderDetail.from_pb(response.order_detail)\n\n    async def cancel_all_gridpool_orders(self, gridpool_id: int) -&gt; int:\n        \"\"\"\n        Cancel all orders for a specific Gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to cancel the orders for.\n\n        Returns:\n            The ID of the Gridpool for which the orders were cancelled.\n        \"\"\"\n        response = await cast(\n            Awaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\n            self._stub.CancelAllGridpoolOrders(\n                electricity_trading_pb2.CancelAllGridpoolOrdersRequest(\n                    gridpool_id=gridpool_id\n                )\n            ),\n        )\n\n        return response.gridpool_id\n\n    async def get_gridpool_order(self, gridpool_id: int, order_id: int) -&gt; OrderDetail:\n        \"\"\"\n        Get a single order from a given gridpool.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the order for.\n            order_id: The order to retrieve.\n\n        Returns:\n            The order.\n        \"\"\"\n        response = await cast(\n            Awaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\n            self._stub.GetGridpoolOrder(\n                electricity_trading_pb2.GetGridpoolOrderRequest(\n                    gridpool_id=gridpool_id, order_id=order_id\n                )\n            ),\n        )\n\n        return OrderDetail.from_pb(response.order_detail)\n\n    async def list_gridpool_orders(  # pylint: disable=too-many-arguments\n        self,\n        gridpool_id: int,\n        states: list[OrderState] | None = None,\n        side: MarketSide | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        delivery_area: DeliveryArea | None = None,\n        tag: str | None = None,\n        max_nr_orders: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; list[OrderDetail]:\n        \"\"\"\n        List orders for a specific Gridpool with optional filters.\n\n        Args:\n            gridpool_id: The Gridpool to retrieve the orders for.\n            states: List of order states to filter by.\n            side: The side of the market to filter by.\n            delivery_period: The delivery period to filter by.\n            delivery_area: The delivery area to filter by.\n            tag: The tag to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n\n        Returns:\n            The list of orders for that gridpool.\n        \"\"\"\n        gridpool_order_filer = GridpoolOrderFilter(\n            states=states,\n            side=side,\n            delivery_period=delivery_period,\n            delivery_area=delivery_area,\n            tag=tag,\n        )\n\n        pagination_params = PaginationParams(\n            page_size=max_nr_orders,\n            page_token=page_token,\n        )\n\n        response = await cast(\n            Awaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\n            self._stub.ListGridpoolOrders(\n                electricity_trading_pb2.ListGridpoolOrdersRequest(\n                    gridpool_id=gridpool_id,\n                    filter=gridpool_order_filer.to_pb(),\n                    pagination_params=pagination_params.to_pb(),\n                )\n            ),\n        )\n\n        return [\n            OrderDetail.from_pb(order_detail)\n            for order_detail in response.order_detail_lists\n        ]\n\n    async def list_public_trades(  # pylint: disable=too-many-arguments\n        self,\n        states: list[OrderState] | None = None,\n        delivery_period: DeliveryPeriod | None = None,\n        buy_delivery_area: DeliveryArea | None = None,\n        sell_delivery_area: DeliveryArea | None = None,\n        max_nr_orders: int | None = None,\n        page_token: str | None = None,\n    ) -&gt; list[PublicTrade]:\n        \"\"\"\n        List all executed public orders with optional filters.\n\n        Args:\n            states: List of order states to filter by.\n            delivery_period: The delivery period to filter by.\n            buy_delivery_area: The buy delivery area to filter by.\n            sell_delivery_area: The sell delivery area to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n\n        Returns:\n            The list of public trades.\n        \"\"\"\n        public_trade_filter = PublicTradeFilter(\n            states=states,\n            delivery_period=delivery_period,\n            buy_delivery_area=buy_delivery_area,\n            sell_delivery_area=sell_delivery_area,\n        )\n\n        pagination_params = PaginationParams(\n            page_size=max_nr_orders,\n            page_token=page_token,\n        )\n\n        response = await cast(\n            Awaitable[electricity_trading_pb2.ListPublicTradesResponse],\n            self._stub.ListPublicTrades(\n                electricity_trading_pb2.ListPublicTradesRequest(\n                    filter=public_trade_filter.to_pb(),\n                    pagination_params=pagination_params.to_pb(),\n                )\n            ),\n        )\n\n        return [\n            PublicTrade.from_pb(public_trade)\n            for public_trade in response.public_trade_lists\n        ]\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__init__","title":"__init__","text":"<pre><code>__init__(grpc_channel: Channel) -&gt; None\n</code></pre> <p>Initialize the client.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>gRPC channel to use for communication with the API.</p> <p> TYPE: <code>Channel</code> </p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>def __init__(self, grpc_channel: grpc.aio.Channel) -&gt; None:\n    \"\"\"Initialize the client.\n\n    Args:\n        grpc_channel: gRPC channel to use for communication with the API.\n    \"\"\"\n    self._stub = electricity_trading_pb2_grpc.ElectricityTradingServiceStub(\n        grpc_channel\n    )\n\n    self._gridpool_orders_streams: dict[\n        tuple[int, GridpoolOrderFilter],\n        GrpcStreamingHelper[\n            electricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n        ],\n    ] = {}\n\n    self._public_trades_streams: dict[\n        PublicTradeFilter,\n        GrpcStreamingHelper[\n            electricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n        ],\n    ] = {}\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_all_gridpool_orders","title":"cancel_all_gridpool_orders  <code>async</code>","text":"<pre><code>cancel_all_gridpool_orders(gridpool_id: int) -&gt; int\n</code></pre> <p>Cancel all orders for a specific Gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the orders for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The ID of the Gridpool for which the orders were cancelled.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_all_gridpool_orders(self, gridpool_id: int) -&gt; int:\n    \"\"\"\n    Cancel all orders for a specific Gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to cancel the orders for.\n\n    Returns:\n        The ID of the Gridpool for which the orders were cancelled.\n    \"\"\"\n    response = await cast(\n        Awaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\n        self._stub.CancelAllGridpoolOrders(\n            electricity_trading_pb2.CancelAllGridpoolOrdersRequest(\n                gridpool_id=gridpool_id\n            )\n        ),\n    )\n\n    return response.gridpool_id\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_gridpool_order","title":"cancel_gridpool_order  <code>async</code>","text":"<pre><code>cancel_gridpool_order(\n    gridpool_id: int, order_id: int\n) -&gt; OrderDetail\n</code></pre> <p>Cancel a single order for a given Gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to cancel.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The cancelled order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_gridpool_order(\n    self, gridpool_id: int, order_id: int\n) -&gt; OrderDetail:\n    \"\"\"\n    Cancel a single order for a given Gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to cancel the order for.\n        order_id: The order to cancel.\n\n    Returns:\n        The cancelled order.\n    \"\"\"\n    response = await cast(\n        Awaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\n        self._stub.CancelGridpoolOrder(\n            electricity_trading_pb2.CancelGridpoolOrderRequest(\n                gridpool_id=gridpool_id, order_id=order_id\n            )\n        ),\n    )\n\n    return OrderDetail.from_pb(response.order_detail)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.create_gridpool_order","title":"create_gridpool_order  <code>async</code>","text":"<pre><code>create_gridpool_order(\n    gridpool_id: int,\n    delivery_area: DeliveryArea,\n    delivery_period: DeliveryPeriod,\n    order_type: OrderType,\n    side: MarketSide,\n    price: Price,\n    quantity: Energy,\n    stop_price: Price | None = None,\n    peak_price_delta: Price | None = None,\n    display_quantity: Energy | None = None,\n    execution_option: OrderExecutionOption | None = None,\n    valid_until: datetime | None = None,\n    payload: dict[str, Value] | None = None,\n    tag: str | None = None,\n) -&gt; OrderDetail\n</code></pre> <p>Create a gridpool order.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to create the order for.</p> <p> TYPE: <code>int</code> </p> <code>delivery_area</code> <p>Delivery area of the order.</p> <p> TYPE: <code>DeliveryArea</code> </p> <code>delivery_period</code> <p>Delivery period of the order.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> <code>order_type</code> <p>Type of the order.</p> <p> TYPE: <code>OrderType</code> </p> <code>side</code> <p>Side of the order.</p> <p> TYPE: <code>MarketSide</code> </p> <code>price</code> <p>Price of the order.</p> <p> TYPE: <code>Price</code> </p> <code>quantity</code> <p>Quantity of the order.</p> <p> TYPE: <code>Energy</code> </p> <code>stop_price</code> <p>Stop price of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>peak_price_delta</code> <p>Peak price delta of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>display_quantity</code> <p>Display quantity of the order.</p> <p> TYPE: <code>Energy | None</code> DEFAULT: <code>None</code> </p> <code>execution_option</code> <p>Execution option of the order.</p> <p> TYPE: <code>OrderExecutionOption | None</code> DEFAULT: <code>None</code> </p> <code>valid_until</code> <p>Valid until of the order.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>payload</code> <p>Payload of the order.</p> <p> TYPE: <code>dict[str, Value] | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag of the order.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The created order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def create_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n    self,\n    gridpool_id: int,\n    delivery_area: DeliveryArea,\n    delivery_period: DeliveryPeriod,\n    order_type: OrderType,\n    side: MarketSide,\n    price: Price,\n    quantity: Energy,\n    stop_price: Price | None = None,\n    peak_price_delta: Price | None = None,\n    display_quantity: Energy | None = None,\n    execution_option: OrderExecutionOption | None = None,\n    valid_until: datetime | None = None,\n    payload: dict[str, struct_pb2.Value] | None = None,\n    tag: str | None = None,\n) -&gt; OrderDetail:\n    \"\"\"\n    Create a gridpool order.\n\n    Args:\n        gridpool_id: ID of the gridpool to create the order for.\n        delivery_area: Delivery area of the order.\n        delivery_period: Delivery period of the order.\n        order_type: Type of the order.\n        side: Side of the order.\n        price: Price of the order.\n        quantity: Quantity of the order.\n        stop_price: Stop price of the order.\n        peak_price_delta: Peak price delta of the order.\n        display_quantity: Display quantity of the order.\n        execution_option: Execution option of the order.\n        valid_until: Valid until of the order.\n        payload: Payload of the order.\n        tag: Tag of the order.\n\n    Returns:\n        The created order.\n    \"\"\"\n    order = Order(\n        delivery_area=delivery_area,\n        delivery_period=delivery_period,\n        type=order_type,\n        side=side,\n        price=price,\n        quantity=quantity,\n        stop_price=stop_price,\n        peak_price_delta=peak_price_delta,\n        display_quantity=display_quantity,\n        execution_option=execution_option,\n        valid_until=valid_until,\n        payload=payload,\n        tag=tag,\n    )\n\n    response = await cast(\n        Awaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\n        self._stub.CreateGridpoolOrder(\n            electricity_trading_pb2.CreateGridpoolOrderRequest(\n                gridpool_id=gridpool_id,\n                order=order.to_pb(),\n            )\n        ),\n    )\n\n    return OrderDetail.from_pb(response.order_detail)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.get_gridpool_order","title":"get_gridpool_order  <code>async</code>","text":"<pre><code>get_gridpool_order(\n    gridpool_id: int, order_id: int\n) -&gt; OrderDetail\n</code></pre> <p>Get a single order from a given gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to retrieve.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The order.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def get_gridpool_order(self, gridpool_id: int, order_id: int) -&gt; OrderDetail:\n    \"\"\"\n    Get a single order from a given gridpool.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the order for.\n        order_id: The order to retrieve.\n\n    Returns:\n        The order.\n    \"\"\"\n    response = await cast(\n        Awaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\n        self._stub.GetGridpoolOrder(\n            electricity_trading_pb2.GetGridpoolOrderRequest(\n                gridpool_id=gridpool_id, order_id=order_id\n            )\n        ),\n    )\n\n    return OrderDetail.from_pb(response.order_detail)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_gridpool_orders","title":"list_gridpool_orders  <code>async</code>","text":"<pre><code>list_gridpool_orders(\n    gridpool_id: int,\n    states: list[OrderState] | None = None,\n    side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    tag: str | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[OrderDetail]\n</code></pre> <p>List orders for a specific Gridpool with optional filters.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the orders for.</p> <p> TYPE: <code>int</code> </p> <code>states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>side</code> <p>The side of the market to filter by.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>The tag to filter by.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[OrderDetail]</code> <p>The list of orders for that gridpool.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_gridpool_orders(  # pylint: disable=too-many-arguments\n    self,\n    gridpool_id: int,\n    states: list[OrderState] | None = None,\n    side: MarketSide | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    delivery_area: DeliveryArea | None = None,\n    tag: str | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[OrderDetail]:\n    \"\"\"\n    List orders for a specific Gridpool with optional filters.\n\n    Args:\n        gridpool_id: The Gridpool to retrieve the orders for.\n        states: List of order states to filter by.\n        side: The side of the market to filter by.\n        delivery_period: The delivery period to filter by.\n        delivery_area: The delivery area to filter by.\n        tag: The tag to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n\n    Returns:\n        The list of orders for that gridpool.\n    \"\"\"\n    gridpool_order_filer = GridpoolOrderFilter(\n        states=states,\n        side=side,\n        delivery_period=delivery_period,\n        delivery_area=delivery_area,\n        tag=tag,\n    )\n\n    pagination_params = PaginationParams(\n        page_size=max_nr_orders,\n        page_token=page_token,\n    )\n\n    response = await cast(\n        Awaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\n        self._stub.ListGridpoolOrders(\n            electricity_trading_pb2.ListGridpoolOrdersRequest(\n                gridpool_id=gridpool_id,\n                filter=gridpool_order_filer.to_pb(),\n                pagination_params=pagination_params.to_pb(),\n            )\n        ),\n    )\n\n    return [\n        OrderDetail.from_pb(order_detail)\n        for order_detail in response.order_detail_lists\n    ]\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_public_trades","title":"list_public_trades  <code>async</code>","text":"<pre><code>list_public_trades(\n    states: list[OrderState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[PublicTrade]\n</code></pre> <p>List all executed public orders with optional filters.</p> PARAMETER  DESCRIPTION <code>states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>The buy delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>The sell delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[PublicTrade]</code> <p>The list of public trades.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_public_trades(  # pylint: disable=too-many-arguments\n    self,\n    states: list[OrderState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n    max_nr_orders: int | None = None,\n    page_token: str | None = None,\n) -&gt; list[PublicTrade]:\n    \"\"\"\n    List all executed public orders with optional filters.\n\n    Args:\n        states: List of order states to filter by.\n        delivery_period: The delivery period to filter by.\n        buy_delivery_area: The buy delivery area to filter by.\n        sell_delivery_area: The sell delivery area to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n\n    Returns:\n        The list of public trades.\n    \"\"\"\n    public_trade_filter = PublicTradeFilter(\n        states=states,\n        delivery_period=delivery_period,\n        buy_delivery_area=buy_delivery_area,\n        sell_delivery_area=sell_delivery_area,\n    )\n\n    pagination_params = PaginationParams(\n        page_size=max_nr_orders,\n        page_token=page_token,\n    )\n\n    response = await cast(\n        Awaitable[electricity_trading_pb2.ListPublicTradesResponse],\n        self._stub.ListPublicTrades(\n            electricity_trading_pb2.ListPublicTradesRequest(\n                filter=public_trade_filter.to_pb(),\n                pagination_params=pagination_params.to_pb(),\n            )\n        ),\n    )\n\n    return [\n        PublicTrade.from_pb(public_trade)\n        for public_trade in response.public_trade_lists\n    ]\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_gridpool_orders","title":"stream_gridpool_orders  <code>async</code>","text":"<pre><code>stream_gridpool_orders(\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_area: DeliveryArea | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    tag: str | None = None,\n) -&gt; Receiver[OrderDetail]\n</code></pre> <p>Stream gridpool orders.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to stream orders for.</p> <p> TYPE: <code>int</code> </p> <code>order_states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>Market side to filter for.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>Delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag to filter for.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[OrderDetail]</code> <p>Async generator of orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_gridpool_orders(  # pylint: disable=too-many-arguments\n    self,\n    gridpool_id: int,\n    order_states: list[OrderState] | None = None,\n    market_side: MarketSide | None = None,\n    delivery_area: DeliveryArea | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    tag: str | None = None,\n) -&gt; Receiver[OrderDetail]:\n    \"\"\"\n    Stream gridpool orders.\n\n    Args:\n        gridpool_id: ID of the gridpool to stream orders for.\n        order_states: List of order states to filter for.\n        market_side: Market side to filter for.\n        delivery_area: Delivery area to filter for.\n        delivery_period: Delivery period to filter for.\n        tag: Tag to filter for.\n\n    Returns:\n        Async generator of orders.\n    \"\"\"\n    gridpool_filter = GridpoolOrderFilter(\n        states=order_states,\n        side=market_side,\n        delivery_area=delivery_area,\n        delivery_period=delivery_period,\n        tag=tag,\n    )\n\n    stream_key = (gridpool_id, gridpool_filter)\n\n    if stream_key not in self._gridpool_orders_streams:\n        self._gridpool_orders_streams[stream_key] = GrpcStreamingHelper(\n            f\"electricity-trading-{stream_key}\",\n            lambda: self._stub.ReceiveGridpoolOrdersStream(  # type: ignore\n                electricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\n                    gridpool_id=gridpool_id,\n                    filter=gridpool_filter.to_pb(),\n                )\n            ),\n            lambda response: OrderDetail.from_pb(response.order_detail),\n        )\n    return self._gridpool_orders_streams[stream_key].new_receiver()\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_public_trades","title":"stream_public_trades  <code>async</code>","text":"<pre><code>stream_public_trades(\n    states: list[OrderState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]\n</code></pre> <p>Stream public orders.</p> PARAMETER  DESCRIPTION <code>states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>Buy delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>Sell delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[PublicTrade]</code> <p>Async generator of orders.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_public_trades(\n    self,\n    states: list[OrderState] | None = None,\n    delivery_period: DeliveryPeriod | None = None,\n    buy_delivery_area: DeliveryArea | None = None,\n    sell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]:\n    \"\"\"\n    Stream public orders.\n\n    Args:\n        states: List of order states to filter for.\n        delivery_period: Delivery period to filter for.\n        buy_delivery_area: Buy delivery area to filter for.\n        sell_delivery_area: Sell delivery area to filter for.\n\n    Returns:\n        Async generator of orders.\n    \"\"\"\n    public_trade_filter = PublicTradeFilter(\n        states=states,\n        delivery_period=delivery_period,\n        buy_delivery_area=buy_delivery_area,\n        sell_delivery_area=sell_delivery_area,\n    )\n\n    if public_trade_filter not in self._public_trades_streams:\n        self._public_trades_streams[public_trade_filter] = GrpcStreamingHelper(\n            f\"electricity-trading-{public_trade_filter}\",\n            lambda: self._stub.ReceivePublicTradesStream(  # type: ignore\n                electricity_trading_pb2.ReceivePublicTradesStreamRequest(\n                    filter=public_trade_filter.to_pb(),\n                )\n            ),\n            lambda response: PublicTrade.from_pb(response.public_trade),\n        )\n    return self._public_trades_streams[public_trade_filter].new_receiver()\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.update_gridpool_order","title":"update_gridpool_order  <code>async</code>","text":"<pre><code>update_gridpool_order(\n    gridpool_id: int,\n    order_id: int,\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Energy | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Energy | None | _Sentinel = NO_VALUE,\n    execution_option: OrderExecutionOption\n    | None\n    | _Sentinel = NO_VALUE,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    payload: dict[str, Value] | None | _Sentinel = NO_VALUE,\n    tag: str | None | _Sentinel = NO_VALUE,\n) -&gt; OrderDetail\n</code></pre> <p>Update an existing order for a given Gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>ID of the Gridpool the order belongs to.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>Order ID.</p> <p> TYPE: <code>int</code> </p> <code>price</code> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>quantity</code> <p>The updated quantity of the contract being traded, specified in MWh.</p> <p> TYPE: <code>Energy | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>stop_price</code> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>peak_price_delta</code> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>display_quantity</code> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p> <p> TYPE: <code>Energy | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>execution_option</code> <p>Updated execution options such as All or None, Fill or Kill, etc.</p> <p> TYPE: <code>OrderExecutionOption | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>valid_until</code> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p> <p> TYPE: <code>datetime | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>payload</code> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p> <p> TYPE: <code>dict[str, Value] | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>tag</code> <p>Updated user-defined tag to group related orders.</p> <p> TYPE: <code>str | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The updated order.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no fields to update are provided.</p> Source code in <code>frequenz/client/electricity_trading/_client.py</code> <pre><code>async def update_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\n    self,\n    gridpool_id: int,\n    order_id: int,\n    price: Price | None | _Sentinel = NO_VALUE,\n    quantity: Energy | None | _Sentinel = NO_VALUE,\n    stop_price: Price | None | _Sentinel = NO_VALUE,\n    peak_price_delta: Price | None | _Sentinel = NO_VALUE,\n    display_quantity: Energy | None | _Sentinel = NO_VALUE,\n    execution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\n    valid_until: datetime | None | _Sentinel = NO_VALUE,\n    payload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\n    tag: str | None | _Sentinel = NO_VALUE,\n) -&gt; OrderDetail:\n    \"\"\"\n    Update an existing order for a given Gridpool.\n\n    Args:\n        gridpool_id: ID of the Gridpool the order belongs to.\n        order_id: Order ID.\n        price: The updated limit price at which the contract is to be traded.\n            This is the maximum price for a BUY order or the minimum price for a SELL order.\n        quantity: The updated quantity of the contract being traded, specified in MWh.\n        stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n            triggers the limit order.\n        peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n            between the peak price and the limit price.\n        display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n            order to be displayed in the order book.\n        execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n        valid_until: This is an updated timestamp defining the time after which the order\n            should be cancelled if not filled. The timestamp is in UTC.\n        payload: Updated user-defined payload individual to a specific order. This can be any\n            data that the user wants to associate with the order.\n        tag: Updated user-defined tag to group related orders.\n\n    Returns:\n        The updated order.\n\n    Raises:\n        ValueError: If no fields to update are provided.\n    \"\"\"\n    params = {\n        \"price\": price,\n        \"quantity\": quantity,\n        \"stop_price\": stop_price,\n        \"peak_price_delta\": peak_price_delta,\n        \"display_quantity\": display_quantity,\n        \"execution_option\": execution_option,\n        \"valid_until\": valid_until,\n        \"payload\": payload,\n        \"tag\": tag,\n    }\n\n    if all(value is NO_VALUE for value in params.values()):\n        raise ValueError(\"At least one field to update must be provided.\")\n\n    paths = [param for param, value in params.items() if value is not NO_VALUE]\n\n    # Field mask specifying which fields should be updated\n    # This is used so that we can update parameters with None values\n    update_mask = field_mask_pb2.FieldMask(paths=paths)\n\n    update_order_fields = UpdateOrder(\n        price=None if price is NO_VALUE else price,\n        quantity=None if quantity is NO_VALUE else quantity,\n        stop_price=None if stop_price is NO_VALUE else stop_price,\n        peak_price_delta=None if peak_price_delta is NO_VALUE else peak_price_delta,\n        display_quantity=None if display_quantity is NO_VALUE else display_quantity,\n        execution_option=None if execution_option is NO_VALUE else execution_option,\n        valid_until=None if valid_until is NO_VALUE else valid_until,\n        payload=None if payload is NO_VALUE else payload,\n        tag=None if tag is NO_VALUE else tag,\n    )\n\n    response = await cast(\n        Awaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\n        self._stub.UpdateGridpoolOrder(\n            electricity_trading_pb2.UpdateGridpoolOrderRequest(\n                gridpool_id=gridpool_id,\n                order_id=order_id,\n                update_order_fields=update_order_fields.to_pb(),\n                update_mask=update_mask,\n            )\n        ),\n    )\n\n    return OrderDetail.from_pb(response.order_detail)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency","title":"frequenz.client.electricity_trading.Currency","text":"<p>             Bases: <code>Enum</code></p> <p>List of supported currencies.</p> <p>New currencies can be added to this enum to support additional markets.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class Currency(enum.Enum):\n    \"\"\"\n    List of supported currencies.\n\n    New currencies can be added to this enum to support additional markets.\n    \"\"\"\n\n    UNSPECIFIED = price_pb2.Price.Currency.CURRENCY_UNSPECIFIED\n    \"\"\"Currency is not specified.\"\"\"\n\n    USD = price_pb2.Price.Currency.CURRENCY_USD\n\n    CAD = price_pb2.Price.Currency.CURRENCY_CAD\n\n    EUR = price_pb2.Price.Currency.CURRENCY_EUR\n\n    GBP = price_pb2.Price.Currency.CURRENCY_GBP\n\n    CHF = price_pb2.Price.Currency.CURRENCY_CHF\n\n    CNY = price_pb2.Price.Currency.CURRENCY_CNY\n\n    JPY = price_pb2.Price.Currency.CURRENCY_JPY\n\n    AUD = price_pb2.Price.Currency.CURRENCY_AUD\n\n    NZD = price_pb2.Price.Currency.CURRENCY_NZD\n\n    SGD = price_pb2.Price.Currency.CURRENCY_SGD\n\n    @classmethod\n    def from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf Currency value to Currency enum.\n\n        Args:\n            currency: Currency to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == currency for e in cls):\n            _logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\n            return cls.UNSPECIFIED\n\n        return cls(currency)\n\n    def to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n        \"\"\"Convert a Currency object to protobuf Currency.\n\n        Returns:\n            Protobuf message corresponding to the Currency object.\n        \"\"\"\n        return price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = CURRENCY_UNSPECIFIED\n</code></pre> <p>Currency is not specified.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(currency: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf Currency value to Currency enum.</p> PARAMETER  DESCRIPTION <code>currency</code> <p>Currency to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf Currency value to Currency enum.\n\n    Args:\n        currency: Currency to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == currency for e in cls):\n        _logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\n        return cls.UNSPECIFIED\n\n    return cls(currency)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a Currency object to protobuf Currency.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the Currency object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n    \"\"\"Convert a Currency object to protobuf Currency.\n\n    Returns:\n        Protobuf message corresponding to the Currency object.\n    \"\"\"\n    return price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea","title":"frequenz.client.electricity_trading.DeliveryArea  <code>dataclass</code>","text":"<p>Geographical or administrative region.</p> <p>These are, usually defined and maintained by a Transmission System Operator (TSO), where electricity deliveries for a contract occur.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass DeliveryArea:\n    \"\"\"\n    Geographical or administrative region.\n\n    These are, usually defined and maintained by a Transmission System Operator (TSO), where\n    electricity deliveries for a contract occur.\n    \"\"\"\n\n    code: str\n    \"\"\"Code representing the unique identifier for the delivery area.\"\"\"\n\n    code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n    \"\"\"Type of code used for identifying the delivery area itself.\"\"\"\n\n    @classmethod\n    def from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n        \"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n\n        Args:\n            delivery_area: DeliveryArea to convert.\n\n        Returns:\n            DeliveryArea object corresponding to the protobuf message.\n        \"\"\"\n        return cls(code=delivery_area.code, code_type=delivery_area.code_type)\n\n    def to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n        \"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryArea object.\n        \"\"\"\n        return delivery_area_pb2.DeliveryArea(code=self.code, code_type=self.code_type)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>Code representing the unique identifier for the delivery area.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code_type","title":"code_type  <code>instance-attribute</code>","text":"<pre><code>code_type: ValueType\n</code></pre> <p>Type of code used for identifying the delivery area itself.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_area: DeliveryArea) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryArea to DeliveryArea object.</p> PARAMETER  DESCRIPTION <code>delivery_area</code> <p>DeliveryArea to convert.</p> <p> TYPE: <code>DeliveryArea</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryArea object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n    \"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n\n    Args:\n        delivery_area: DeliveryArea to convert.\n\n    Returns:\n        DeliveryArea object corresponding to the protobuf message.\n    \"\"\"\n    return cls(code=delivery_area.code, code_type=delivery_area.code_type)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryArea\n</code></pre> <p>Convert a DeliveryArea object to protobuf DeliveryArea.</p> RETURNS DESCRIPTION <code>DeliveryArea</code> <p>Protobuf message corresponding to the DeliveryArea object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n    \"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryArea object.\n    \"\"\"\n    return delivery_area_pb2.DeliveryArea(code=self.code, code_type=self.code_type)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration","title":"frequenz.client.electricity_trading.DeliveryDuration","text":"<p>             Bases: <code>Enum</code></p> <p>Specifies the time increment, in minutes, used for electricity deliveries and trading.</p> <p>These durations serve as the basis for defining the delivery period in contracts, and they dictate how energy is scheduled and delivered to meet contractual obligations.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class DeliveryDuration(enum.Enum):\n    \"\"\"\n    Specifies the time increment, in minutes, used for electricity deliveries and trading.\n\n    These durations serve as the basis for defining the delivery period in contracts, and they\n    dictate how energy is scheduled and delivered to meet contractual obligations.\n    \"\"\"\n\n    UNSPECIFIED = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_UNSPECIFIED\n    \"\"\"Default value, indicates that the duration is unspecified.\"\"\"\n\n    MINUTES_5 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_5\n    \"\"\"5-minute duration.\"\"\"\n\n    MINUTES_15 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_15\n    \"\"\"15-minute contract duration.\"\"\"\n\n    MINUTES_30 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_30\n    \"\"\"30-minute contract duration.\"\"\"\n\n    MINUTES_60 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_60\n    \"\"\"1-hour contract duration.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n\n        Args:\n            delivery_duration: Delivery duration to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == delivery_duration for e in cls):\n            _logger.warning(\n                \"Unknown delivery duration %s. Returning UNSPECIFIED.\",\n                delivery_duration,\n            )\n            return cls.UNSPECIFIED\n\n        return cls(delivery_duration)\n\n    def to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n        \"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryDuration object.\n        \"\"\"\n        return delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_15","title":"MINUTES_15  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_15 = DELIVERY_DURATION_15\n</code></pre> <p>15-minute contract duration.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_30","title":"MINUTES_30  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_30 = DELIVERY_DURATION_30\n</code></pre> <p>30-minute contract duration.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_5","title":"MINUTES_5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_5 = DELIVERY_DURATION_5\n</code></pre> <p>5-minute duration.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_60","title":"MINUTES_60  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_60 = DELIVERY_DURATION_60\n</code></pre> <p>1-hour contract duration.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = DELIVERY_DURATION_UNSPECIFIED\n</code></pre> <p>Default value, indicates that the duration is unspecified.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_duration: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryDuration value to DeliveryDuration enum.</p> PARAMETER  DESCRIPTION <code>delivery_duration</code> <p>Delivery duration to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n) -&gt; Self:\n    \"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n\n    Args:\n        delivery_duration: Delivery duration to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == delivery_duration for e in cls):\n        _logger.warning(\n            \"Unknown delivery duration %s. Returning UNSPECIFIED.\",\n            delivery_duration,\n        )\n        return cls.UNSPECIFIED\n\n    return cls(delivery_duration)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a DeliveryDuration object to protobuf DeliveryDuration.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the DeliveryDuration object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n    \"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryDuration object.\n    \"\"\"\n    return delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod","title":"frequenz.client.electricity_trading.DeliveryPeriod  <code>dataclass</code>","text":"<p>Time period during which the contract is delivered.</p> <p>It is defined by a start timestamp and a duration.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass DeliveryPeriod:\n    \"\"\"\n    Time period during which the contract is delivered.\n\n    It is defined by a start timestamp and a duration.\n    \"\"\"\n\n    start: datetime\n    \"\"\"Start UTC timestamp represents the beginning of the delivery period.\n        This timestamp is inclusive, meaning that the delivery period starts\n        from this point in time.\"\"\"\n\n    duration: DeliveryDuration\n    \"\"\"The length of the delivery period.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the parameters.\"\"\"\n        if not isinstance(self.start, datetime):\n            raise ValueError(\"Start must be a datetime object.\")\n        if not isinstance(self.duration, DeliveryDuration):\n            raise ValueError(\"Duration must be a DeliveryDuration object.\")\n\n    @classmethod\n    def from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n        \"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n\n        Args:\n            delivery_period: DeliveryPeriod to convert.\n\n        Returns:\n            DeliveryPeriod object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            start=delivery_period.start.ToDatetime(),\n            duration=DeliveryDuration.from_pb(delivery_period.duration),\n        )\n\n    def to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n        \"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n\n        Returns:\n            Protobuf message corresponding to the DeliveryPeriod object.\n        \"\"\"\n        start = timestamp_pb2.Timestamp()\n        start.FromDatetime(self.start)\n        return delivery_duration_pb2.DeliveryPeriod(\n            start=start,\n            duration=self.duration.to_pb(),\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: DeliveryDuration\n</code></pre> <p>The length of the delivery period.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: datetime\n</code></pre> <p>Start UTC timestamp represents the beginning of the delivery period. This timestamp is inclusive, meaning that the delivery period starts from this point in time.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Validate the parameters.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the parameters.\"\"\"\n    if not isinstance(self.start, datetime):\n        raise ValueError(\"Start must be a datetime object.\")\n    if not isinstance(self.duration, DeliveryDuration):\n        raise ValueError(\"Duration must be a DeliveryDuration object.\")\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_period: DeliveryPeriod) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryPeriod to DeliveryPeriod object.</p> PARAMETER  DESCRIPTION <code>delivery_period</code> <p>DeliveryPeriod to convert.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryPeriod object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n    \"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n\n    Args:\n        delivery_period: DeliveryPeriod to convert.\n\n    Returns:\n        DeliveryPeriod object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        start=delivery_period.start.ToDatetime(),\n        duration=DeliveryDuration.from_pb(delivery_period.duration),\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryPeriod\n</code></pre> <p>Convert a DeliveryPeriod object to protobuf DeliveryPeriod.</p> RETURNS DESCRIPTION <code>DeliveryPeriod</code> <p>Protobuf message corresponding to the DeliveryPeriod object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n    \"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n\n    Returns:\n        Protobuf message corresponding to the DeliveryPeriod object.\n    \"\"\"\n    start = timestamp_pb2.Timestamp()\n    start.FromDatetime(self.start)\n    return delivery_duration_pb2.DeliveryPeriod(\n        start=start,\n        duration=self.duration.to_pb(),\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy","title":"frequenz.client.electricity_trading.Energy  <code>dataclass</code>","text":"<p>Represents energy unit in Megawatthours (MWh).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Energy:\n    \"\"\"Represents energy unit in Megawatthours (MWh).\"\"\"\n\n    mwh: Decimal\n\n    @classmethod\n    def from_pb(cls, energy: energy_pb2.Energy) -&gt; Self:\n        \"\"\"Convert a protobuf Energy to Energy object.\n\n        Args:\n            energy: Energy to convert.\n\n        Returns:\n            Energy object corresponding to the protobuf message.\n        \"\"\"\n        return cls(mwh=Decimal(energy.mwh.value))\n\n    def to_pb(self) -&gt; energy_pb2.Energy:\n        \"\"\"Convert a Energy object to protobuf Energy.\n\n        Returns:\n            Protobuf message corresponding to the Energy object.\n        \"\"\"\n        decimal_mwh = decimal_pb2.Decimal()\n        decimal_mwh.value = str(self.mwh)\n        return energy_pb2.Energy(mwh=decimal_mwh)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(energy: Energy) -&gt; Self\n</code></pre> <p>Convert a protobuf Energy to Energy object.</p> PARAMETER  DESCRIPTION <code>energy</code> <p>Energy to convert.</p> <p> TYPE: <code>Energy</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Energy object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, energy: energy_pb2.Energy) -&gt; Self:\n    \"\"\"Convert a protobuf Energy to Energy object.\n\n    Args:\n        energy: Energy to convert.\n\n    Returns:\n        Energy object corresponding to the protobuf message.\n    \"\"\"\n    return cls(mwh=Decimal(energy.mwh.value))\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Energy\n</code></pre> <p>Convert a Energy object to protobuf Energy.</p> RETURNS DESCRIPTION <code>Energy</code> <p>Protobuf message corresponding to the Energy object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; energy_pb2.Energy:\n    \"\"\"Convert a Energy object to protobuf Energy.\n\n    Returns:\n        Protobuf message corresponding to the Energy object.\n    \"\"\"\n    decimal_mwh = decimal_pb2.Decimal()\n    decimal_mwh.value = str(self.mwh)\n    return energy_pb2.Energy(mwh=decimal_mwh)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType","title":"frequenz.client.electricity_trading.EnergyMarketCodeType","text":"<p>             Bases: <code>Enum</code></p> <p>Specifies the type of identification code used in the energy market.</p> <p>This is used for uniquely identifying various entities such as delivery areas, market participants, and grid components. This enumeration aims to offer compatibility across different jurisdictional standards.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class EnergyMarketCodeType(enum.Enum):\n    \"\"\"\n    Specifies the type of identification code used in the energy market.\n\n    This is used for uniquely identifying various entities such as delivery areas, market\n    participants, and grid components. This enumeration aims to offer compatibility across\n    different jurisdictional standards.\n    \"\"\"\n\n    UNSPECIFIED = (\n        delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n    )\n    \"\"\"Unspecified type. This value is a placeholder and should not be used.\"\"\"\n\n    EUROPE_EIC = (\n        delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n    )\n    \"\"\"European Energy Identification Code Standard.\"\"\"\n\n    US_NERC = delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_US_NERC\n    \"\"\"North American Electric Reliability Corporation identifiers.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n\n        Args:\n            energy_market_code_type: Energy market code type to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == energy_market_code_type for e in cls):\n            _logger.warning(\n                \"Unknown energy market code type %s. Returning UNSPECIFIED.\",\n                energy_market_code_type,\n            )\n            return cls.UNSPECIFIED\n\n        return cls(energy_market_code_type)\n\n    def to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n        \"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n\n        Returns:\n            Protobuf message corresponding to the EnergyMarketCodeType object.\n        \"\"\"\n        return delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.EUROPE_EIC","title":"EUROPE_EIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EUROPE_EIC = ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n</code></pre> <p>European Energy Identification Code Standard.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified type. This value is a placeholder and should not be used.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.US_NERC","title":"US_NERC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>US_NERC = ENERGY_MARKET_CODE_TYPE_US_NERC\n</code></pre> <p>North American Electric Reliability Corporation identifiers.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(energy_market_code_type: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.</p> PARAMETER  DESCRIPTION <code>energy_market_code_type</code> <p>Energy market code type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n) -&gt; Self:\n    \"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n\n    Args:\n        energy_market_code_type: Energy market code type to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == energy_market_code_type for e in cls):\n        _logger.warning(\n            \"Unknown energy market code type %s. Returning UNSPECIFIED.\",\n            energy_market_code_type,\n        )\n        return cls.UNSPECIFIED\n\n    return cls(energy_market_code_type)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the EnergyMarketCodeType object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n    \"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n\n    Returns:\n        Protobuf message corresponding to the EnergyMarketCodeType object.\n    \"\"\"\n    return delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter","title":"frequenz.client.electricity_trading.GridpoolOrderFilter  <code>dataclass</code>","text":"<p>Parameters for filtering Gridpool orders.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass GridpoolOrderFilter:\n    \"\"\"Parameters for filtering Gridpool orders.\"\"\"\n\n    states: list[OrderState] | None\n    \"\"\"List of order states to filter for.\"\"\"\n\n    side: MarketSide | None\n    \"\"\"Market side to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    delivery_area: DeliveryArea | None\n    \"\"\"Delivery area to filter for.\"\"\"\n\n    tag: str | None\n    \"\"\"Tag associated with the orders to be filtered.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n\n        Args:\n            gridpool_order_filter: GridpoolOrderFilter to convert.\n\n        Returns:\n            GridpoolOrderFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            states=[\n                OrderState.from_pb(state) for state in gridpool_order_filter.states\n            ],\n            side=MarketSide.from_pb(gridpool_order_filter.side),\n            delivery_period=DeliveryPeriod.from_pb(\n                gridpool_order_filter.delivery_period\n            ),\n            delivery_area=DeliveryArea.from_pb(gridpool_order_filter.delivery_area),\n            tag=gridpool_order_filter.tag,\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n        \"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n\n        Returns:\n            Protobuf GridpoolOrderFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.GridpoolOrderFilter(\n            states=[\n                electricity_trading_pb2.OrderState.ValueType(state.value)\n                for state in self.states\n            ]\n            if self.states\n            else None,\n            side=electricity_trading_pb2.MarketSide.ValueType(self.side.value)\n            if self.side\n            else None,\n            delivery_period=self.delivery_period.to_pb()\n            if self.delivery_period\n            else None,\n            delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea | None\n</code></pre> <p>Delivery area to filter for.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide | None\n</code></pre> <p>Market side to filter for.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.states","title":"states  <code>instance-attribute</code>","text":"<pre><code>states: list[OrderState] | None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str | None\n</code></pre> <p>Tag associated with the orders to be filtered.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(gridpool_order_filter: GridpoolOrderFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.</p> PARAMETER  DESCRIPTION <code>gridpool_order_filter</code> <p>GridpoolOrderFilter to convert.</p> <p> TYPE: <code>GridpoolOrderFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>GridpoolOrderFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n) -&gt; Self:\n    \"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n\n    Args:\n        gridpool_order_filter: GridpoolOrderFilter to convert.\n\n    Returns:\n        GridpoolOrderFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        states=[\n            OrderState.from_pb(state) for state in gridpool_order_filter.states\n        ],\n        side=MarketSide.from_pb(gridpool_order_filter.side),\n        delivery_period=DeliveryPeriod.from_pb(\n            gridpool_order_filter.delivery_period\n        ),\n        delivery_area=DeliveryArea.from_pb(gridpool_order_filter.delivery_area),\n        tag=gridpool_order_filter.tag,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; GridpoolOrderFilter\n</code></pre> <p>Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.</p> RETURNS DESCRIPTION <code>GridpoolOrderFilter</code> <p>Protobuf GridpoolOrderFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n    \"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n\n    Returns:\n        Protobuf GridpoolOrderFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.GridpoolOrderFilter(\n        states=[\n            electricity_trading_pb2.OrderState.ValueType(state.value)\n            for state in self.states\n        ]\n        if self.states\n        else None,\n        side=electricity_trading_pb2.MarketSide.ValueType(self.side.value)\n        if self.side\n        else None,\n        delivery_period=self.delivery_period.to_pb()\n        if self.delivery_period\n        else None,\n        delivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide","title":"frequenz.client.electricity_trading.MarketSide","text":"<p>             Bases: <code>Enum</code></p> <p>Which side of the market the order is on, either buying or selling.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class MarketSide(enum.Enum):\n    \"\"\"Which side of the market the order is on, either buying or selling.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.MarketSide.MARKET_SIDE_UNSPECIFIED\n    \"\"\"The side of the market has not been set.\"\"\"\n\n    BUY = electricity_trading_pb2.MarketSide.MARKET_SIDE_BUY\n    \"\"\"Order to purchase electricity, referred to as a 'bid' in the order book.\"\"\"\n\n    SELL = electricity_trading_pb2.MarketSide.MARKET_SIDE_SELL\n    \"\"\"Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.\"\"\"\n\n    @classmethod\n    def from_pb(cls, market_side: electricity_trading_pb2.MarketSide.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n\n        Args:\n            market_side: Market side to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == market_side for e in cls):\n            _logger.warning(\n                \"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n            )\n            return cls.UNSPECIFIED\n\n        return cls(market_side)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n        \"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n\n        Returns:\n            Protobuf message corresponding to the MarketSide enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.BUY","title":"BUY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUY = MARKET_SIDE_BUY\n</code></pre> <p>Order to purchase electricity, referred to as a 'bid' in the order book.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.SELL","title":"SELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SELL = MARKET_SIDE_SELL\n</code></pre> <p>Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = MARKET_SIDE_UNSPECIFIED\n</code></pre> <p>The side of the market has not been set.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(market_side: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf MarketSide value to MarketSide enum.</p> PARAMETER  DESCRIPTION <code>market_side</code> <p>Market side to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, market_side: electricity_trading_pb2.MarketSide.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n\n    Args:\n        market_side: Market side to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == market_side for e in cls):\n        _logger.warning(\n            \"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n        )\n        return cls.UNSPECIFIED\n\n    return cls(market_side)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a MarketSide enum to protobuf MarketSide value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the MarketSide enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n    \"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n\n    Returns:\n        Protobuf message corresponding to the MarketSide enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order","title":"frequenz.client.electricity_trading.Order  <code>dataclass</code>","text":"<p>Represents an order in the electricity market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Order:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents an order in the electricity market.\"\"\"\n\n    delivery_area: DeliveryArea\n    \"\"\"The delivery area where the contract is to be delivered.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    type: OrderType\n    \"\"\"The type of order.\"\"\"\n\n    side: MarketSide\n    \"\"\"Indicates if the order is on the Buy or Sell side of the market.\"\"\"\n\n    price: Price\n    \"\"\"The limit price at which the contract is to be traded.\"\"\"\n\n    quantity: Energy\n    \"\"\"The quantity of the contract being traded.\"\"\"\n\n    stop_price: Price | None\n    \"\"\"Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.\"\"\"\n\n    peak_price_delta: Price | None\n    \"\"\"Applicable for ICEBERG orders. The price difference between the peak price and\n    the limit price.\"\"\"\n\n    display_quantity: Energy | None\n    \"\"\"Applicable for ICEBERG orders. The quantity of the order to be displayed in the order\n    book.\"\"\"\n\n    execution_option: OrderExecutionOption | None\n    \"\"\"Order execution options such as All or None, Fill or Kill, etc.\"\"\"\n\n    valid_until: datetime | None\n    \"\"\"UTC timestamp defining the time after which the order should be cancelled if not filled.\"\"\"\n\n    payload: dict[str, struct_pb2.Value] | None\n    \"\"\"User-defined payload individual to a specific order. This can be any data that needs to be\n    associated with the order.\"\"\"\n\n    tag: str | None\n    \"\"\"User-defined tag to group related orders.\"\"\"\n\n    @classmethod\n    def from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n        \"\"\"Convert a protobuf Order to Order object.\n\n        Args:\n            order: Order to convert.\n\n        Returns:\n            Order object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            delivery_area=DeliveryArea.from_pb(order.delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(order.delivery_period),\n            type=OrderType.from_pb(order.type),\n            side=MarketSide.from_pb(order.side),\n            price=Price.from_pb(order.price),\n            quantity=Energy.from_pb(order.quantity),\n            stop_price=Price.from_pb(order.stop_price) if order.stop_price else None,\n            peak_price_delta=Price.from_pb(order.peak_price_delta)\n            if order.peak_price_delta\n            else None,\n            display_quantity=Energy.from_pb(order.display_quantity)\n            if order.display_quantity\n            else None,\n            execution_option=OrderExecutionOption.from_pb(order.execution_option)\n            if order.execution_option\n            else None,\n            valid_until=order.valid_until.ToDatetime() if order.valid_until else None,\n            payload=json_format.MessageToDict(order.payload) if order.payload else None,\n            tag=order.tag if order.tag else None,\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.Order:\n        \"\"\"\n        Convert an Order object to protobuf Order.\n\n        Returns:\n            Protobuf message corresponding to the Order object.\n        \"\"\"\n        if self.valid_until:\n            valid_until = timestamp_pb2.Timestamp()\n            valid_until.FromDatetime(self.valid_until)\n        else:\n            valid_until = None\n        return electricity_trading_pb2.Order(\n            delivery_area=self.delivery_area.to_pb(),\n            delivery_period=self.delivery_period.to_pb(),\n            type=electricity_trading_pb2.OrderType.ValueType(self.type.value),\n            side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n            price=self.price.to_pb(),\n            quantity=self.quantity.to_pb(),\n            stop_price=self.stop_price.to_pb() if self.stop_price else None,\n            peak_price_delta=self.peak_price_delta.to_pb()\n            if self.peak_price_delta\n            else None,\n            display_quantity=self.display_quantity.to_pb()\n            if self.display_quantity\n            else None,\n            execution_option=(\n                electricity_trading_pb2.OrderExecutionOption.ValueType(\n                    self.execution_option.value\n                )\n                if self.execution_option\n                else None\n            ),\n            valid_until=valid_until,\n            payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>The delivery area where the contract is to be delivered.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.display_quantity","title":"display_quantity  <code>instance-attribute</code>","text":"<pre><code>display_quantity: Energy | None\n</code></pre> <p>Applicable for ICEBERG orders. The quantity of the order to be displayed in the order book.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.execution_option","title":"execution_option  <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None\n</code></pre> <p>Order execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None\n</code></pre> <p>User-defined payload individual to a specific order. This can be any data that needs to be associated with the order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.peak_price_delta","title":"peak_price_delta  <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None\n</code></pre> <p>Applicable for ICEBERG orders. The price difference between the peak price and the limit price.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide\n</code></pre> <p>Indicates if the order is on the Buy or Sell side of the market.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.stop_price","title":"stop_price  <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None\n</code></pre> <p>Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str | None\n</code></pre> <p>User-defined tag to group related orders.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: OrderType\n</code></pre> <p>The type of order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.valid_until","title":"valid_until  <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None\n</code></pre> <p>UTC timestamp defining the time after which the order should be cancelled if not filled.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order: Order) -&gt; Self\n</code></pre> <p>Convert a protobuf Order to Order object.</p> PARAMETER  DESCRIPTION <code>order</code> <p>Order to convert.</p> <p> TYPE: <code>Order</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Order object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n    \"\"\"Convert a protobuf Order to Order object.\n\n    Args:\n        order: Order to convert.\n\n    Returns:\n        Order object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        delivery_area=DeliveryArea.from_pb(order.delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(order.delivery_period),\n        type=OrderType.from_pb(order.type),\n        side=MarketSide.from_pb(order.side),\n        price=Price.from_pb(order.price),\n        quantity=Energy.from_pb(order.quantity),\n        stop_price=Price.from_pb(order.stop_price) if order.stop_price else None,\n        peak_price_delta=Price.from_pb(order.peak_price_delta)\n        if order.peak_price_delta\n        else None,\n        display_quantity=Energy.from_pb(order.display_quantity)\n        if order.display_quantity\n        else None,\n        execution_option=OrderExecutionOption.from_pb(order.execution_option)\n        if order.execution_option\n        else None,\n        valid_until=order.valid_until.ToDatetime() if order.valid_until else None,\n        payload=json_format.MessageToDict(order.payload) if order.payload else None,\n        tag=order.tag if order.tag else None,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Order\n</code></pre> <p>Convert an Order object to protobuf Order.</p> RETURNS DESCRIPTION <code>Order</code> <p>Protobuf message corresponding to the Order object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.Order:\n    \"\"\"\n    Convert an Order object to protobuf Order.\n\n    Returns:\n        Protobuf message corresponding to the Order object.\n    \"\"\"\n    if self.valid_until:\n        valid_until = timestamp_pb2.Timestamp()\n        valid_until.FromDatetime(self.valid_until)\n    else:\n        valid_until = None\n    return electricity_trading_pb2.Order(\n        delivery_area=self.delivery_area.to_pb(),\n        delivery_period=self.delivery_period.to_pb(),\n        type=electricity_trading_pb2.OrderType.ValueType(self.type.value),\n        side=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\n        price=self.price.to_pb(),\n        quantity=self.quantity.to_pb(),\n        stop_price=self.stop_price.to_pb() if self.stop_price else None,\n        peak_price_delta=self.peak_price_delta.to_pb()\n        if self.peak_price_delta\n        else None,\n        display_quantity=self.display_quantity.to_pb()\n        if self.display_quantity\n        else None,\n        execution_option=(\n            electricity_trading_pb2.OrderExecutionOption.ValueType(\n                self.execution_option.value\n            )\n            if self.execution_option\n            else None\n        ),\n        valid_until=valid_until,\n        payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail","title":"frequenz.client.electricity_trading.OrderDetail  <code>dataclass</code>","text":"<p>Represents an order with full details, including its ID, state, and associated UTC timestamps.</p> ATTRIBUTE DESCRIPTION <code>order_id</code> <p>Unique identifier of the order.</p> <p> TYPE: <code>int</code> </p> <code>order</code> <p>The details of the order.</p> <p> TYPE: <code>Order</code> </p> <code>state_detail</code> <p>Details of the order's current state.</p> <p> TYPE: <code>StateDetail</code> </p> <code>open_quantity</code> <p>Remaining open quantity for this order.</p> <p> TYPE: <code>Energy</code> </p> <code>filled_quantity</code> <p>Filled quantity for this order.</p> <p> TYPE: <code>Energy</code> </p> <code>create_time</code> <p>UTC Timestamp when the order was created.</p> <p> TYPE: <code>datetime</code> </p> <code>modification_time</code> <p>UTC Timestamp of the last update to the order.</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass OrderDetail:\n    \"\"\"\n    Represents an order with full details, including its ID, state, and associated UTC timestamps.\n\n    Attributes:\n        order_id: Unique identifier of the order.\n        order: The details of the order.\n        state_detail: Details of the order's current state.\n        open_quantity: Remaining open quantity for this order.\n        filled_quantity: Filled quantity for this order.\n        create_time: UTC Timestamp when the order was created.\n        modification_time: UTC Timestamp of the last update to the order.\n    \"\"\"\n\n    order_id: int\n    order: Order\n    state_detail: StateDetail\n    open_quantity: Energy\n    filled_quantity: Energy\n    create_time: datetime\n    modification_time: datetime\n\n    @classmethod\n    def from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n        \"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n\n        Args:\n            order_detail: OrderDetail to convert.\n\n        Returns:\n            OrderDetail object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            order_id=order_detail.order_id,\n            order=Order.from_pb(order_detail.order),\n            state_detail=StateDetail.from_pb(order_detail.state_detail),\n            open_quantity=Energy.from_pb(order_detail.open_quantity),\n            filled_quantity=Energy.from_pb(order_detail.filled_quantity),\n            create_time=order_detail.create_time.ToDatetime(),\n            modification_time=order_detail.modification_time.ToDatetime(),\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_detail: OrderDetail) -&gt; Self\n</code></pre> <p>Convert a protobuf OrderDetail to OrderDetail object.</p> PARAMETER  DESCRIPTION <code>order_detail</code> <p>OrderDetail to convert.</p> <p> TYPE: <code>OrderDetail</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>OrderDetail object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n    \"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n\n    Args:\n        order_detail: OrderDetail to convert.\n\n    Returns:\n        OrderDetail object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        order_id=order_detail.order_id,\n        order=Order.from_pb(order_detail.order),\n        state_detail=StateDetail.from_pb(order_detail.state_detail),\n        open_quantity=Energy.from_pb(order_detail.open_quantity),\n        filled_quantity=Energy.from_pb(order_detail.filled_quantity),\n        create_time=order_detail.create_time.ToDatetime(),\n        modification_time=order_detail.modification_time.ToDatetime(),\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption","title":"frequenz.client.electricity_trading.OrderExecutionOption","text":"<p>             Bases: <code>Enum</code></p> <p>Specific behavior for the execution of an order.</p> <p>These options provide control on how an order is handled in the market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderExecutionOption(enum.Enum):\n    \"\"\"\n    Specific behavior for the execution of an order.\n\n    These options provide control on how an order is handled in the market.\n    \"\"\"\n\n    UNSPECIFIED = (\n        electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_UNSPECIFIED\n    )\n    \"\"\"The order execution option has not been set.\"\"\"\n\n    NONE = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_NONE\n    \"\"\"Order remains open until it's fully filled, cancelled by the client,\n    `valid_until` timestamp is reached, or the end of the trading session.\"\"\"\n\n    AON = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_AON\n    \"\"\"All or None: Order must be executed in its entirety, or not executed at all.\"\"\"\n\n    FOK = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_FOK\n    \"\"\"Fill or Kill: Order must be executed immediately in its entirety, or not at all.\"\"\"\n\n    IOC = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_IOC\n    \"\"\"Immediate or Cancel: Any portion of an order that cannot be filled \\\n    immediately will be cancelled.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        order_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n\n        Args:\n            order_execution_option: order execution option to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_execution_option for e in OrderExecutionOption):\n            _logger.warning(\n                \"Unknown forecast feature %s. Returning UNSPECIFIED.\",\n                order_execution_option,\n            )\n            return cls.UNSPECIFIED\n\n        return OrderExecutionOption(order_execution_option)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.AON","title":"AON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AON = ORDER_EXECUTION_OPTION_AON\n</code></pre> <p>All or None: Order must be executed in its entirety, or not executed at all.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.FOK","title":"FOK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOK = ORDER_EXECUTION_OPTION_FOK\n</code></pre> <p>Fill or Kill: Order must be executed immediately in its entirety, or not at all.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.IOC","title":"IOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IOC = ORDER_EXECUTION_OPTION_IOC\n</code></pre> <p>Immediate or Cancel: Any portion of an order that cannot be filled     immediately will be cancelled.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.NONE","title":"NONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NONE = ORDER_EXECUTION_OPTION_NONE\n</code></pre> <p>Order remains open until it's fully filled, cancelled by the client, <code>valid_until</code> timestamp is reached, or the end of the trading session.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_EXECUTION_OPTION_UNSPECIFIED\n</code></pre> <p>The order execution option has not been set.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_execution_option: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.</p> PARAMETER  DESCRIPTION <code>order_execution_option</code> <p>order execution option to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    order_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n) -&gt; Self:\n    \"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n\n    Args:\n        order_execution_option: order execution option to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_execution_option for e in OrderExecutionOption):\n        _logger.warning(\n            \"Unknown forecast feature %s. Returning UNSPECIFIED.\",\n            order_execution_option,\n        )\n        return cls.UNSPECIFIED\n\n    return OrderExecutionOption(order_execution_option)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState","title":"frequenz.client.electricity_trading.OrderState","text":"<p>             Bases: <code>Enum</code></p> <p>State of an order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderState(enum.Enum):\n    \"\"\"State of an order.\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.OrderState.ORDER_STATE_UNSPECIFIED\n    \"\"\"The order state is not known. Usually the default state of a newly created order object\n    before any operations have been applied.\"\"\"\n\n    PENDING = electricity_trading_pb2.OrderState.ORDER_STATE_PENDING\n    \"\"\"The order has been sent to the marketplace but has not yet been confirmed. This can be due\n    to awaiting validation or system processing.\"\"\"\n\n    ACTIVE = electricity_trading_pb2.OrderState.ORDER_STATE_ACTIVE\n    \"\"\"The order has been confirmed and is open in the market. It may be unfilled or partially\n    filled.\"\"\"\n\n    FILLED = electricity_trading_pb2.OrderState.ORDER_STATE_FILLED\n    \"\"\"The order has been completely filled and there are no remaining quantities on the order.\"\"\"\n\n    CANCELED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCELED\n    \"\"\"The order has been canceled. This can occur due to a cancellation request by the market\n    participant, system, or market operator.\"\"\"\n\n    CANCEL_REQUESTED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCEL_REQUESTED\n    \"\"\"A cancellation request for the order has been submitted but the order is not yet removed\n    from the order book.\"\"\"\n\n    CANCEL_REJECTED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCEL_REJECTED\n    \"\"\"The order cancellation request was rejected, likely due to it having already been filled or\n    expired.\"\"\"\n\n    EXPIRED = electricity_trading_pb2.OrderState.ORDER_STATE_EXPIRED\n    \"\"\"The order has not been filled within the defined duration and has expired.\"\"\"\n\n    FAILED = electricity_trading_pb2.OrderState.ORDER_STATE_FAILED\n    \"\"\"The order submission failed and was unable to be placed on the order book, usually due to a\n    validation error or system issue.\"\"\"\n\n    HIBERNATE = electricity_trading_pb2.OrderState.ORDER_STATE_HIBERNATE\n    \"\"\"The order has been entered into the system but is not currently exposed to the market. This\n    could be due to certain conditions not yet being met.\"\"\"\n\n    RECALL = electricity_trading_pb2.OrderState.ORDER_STATE_RECALL\n    \"\"\"The order has been recalled. This could be due to a system issue or a request from the\n    market participant or market operator.\"\"\"\n\n    @classmethod\n    def from_pb(cls, order_state: electricity_trading_pb2.OrderState.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf OrderState value to OrderState enum.\n\n        Args:\n            order_state: Order state to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_state for e in cls):\n            _logger.warning(\n                \"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n            )\n            return cls.UNSPECIFIED\n\n        return cls(order_state)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n        \"\"\"Convert an OrderState enum to protobuf OrderState value.\n\n        Returns:\n            Protobuf message corresponding to the OrderState enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = ORDER_STATE_ACTIVE\n</code></pre> <p>The order has been confirmed and is open in the market. It may be unfilled or partially filled.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCELED","title":"CANCELED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELED = ORDER_STATE_CANCELED\n</code></pre> <p>The order has been canceled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCEL_REJECTED","title":"CANCEL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REJECTED = ORDER_STATE_CANCEL_REJECTED\n</code></pre> <p>The order cancellation request was rejected, likely due to it having already been filled or expired.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCEL_REQUESTED","title":"CANCEL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REQUESTED = ORDER_STATE_CANCEL_REQUESTED\n</code></pre> <p>A cancellation request for the order has been submitted but the order is not yet removed from the order book.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.EXPIRED","title":"EXPIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXPIRED = ORDER_STATE_EXPIRED\n</code></pre> <p>The order has not been filled within the defined duration and has expired.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = ORDER_STATE_FAILED\n</code></pre> <p>The order submission failed and was unable to be placed on the order book, usually due to a validation error or system issue.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FILLED","title":"FILLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILLED = ORDER_STATE_FILLED\n</code></pre> <p>The order has been completely filled and there are no remaining quantities on the order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.HIBERNATE","title":"HIBERNATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIBERNATE = ORDER_STATE_HIBERNATE\n</code></pre> <p>The order has been entered into the system but is not currently exposed to the market. This could be due to certain conditions not yet being met.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.PENDING","title":"PENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PENDING = ORDER_STATE_PENDING\n</code></pre> <p>The order has been sent to the marketplace but has not yet been confirmed. This can be due to awaiting validation or system processing.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.RECALL","title":"RECALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL = ORDER_STATE_RECALL\n</code></pre> <p>The order has been recalled. This could be due to a system issue or a request from the market participant or market operator.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_STATE_UNSPECIFIED\n</code></pre> <p>The order state is not known. Usually the default state of a newly created order object before any operations have been applied.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_state: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf OrderState value to OrderState enum.</p> PARAMETER  DESCRIPTION <code>order_state</code> <p>Order state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order_state: electricity_trading_pb2.OrderState.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf OrderState value to OrderState enum.\n\n    Args:\n        order_state: Order state to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_state for e in cls):\n        _logger.warning(\n            \"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n        )\n        return cls.UNSPECIFIED\n\n    return cls(order_state)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderState enum to protobuf OrderState value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderState enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n    \"\"\"Convert an OrderState enum to protobuf OrderState value.\n\n    Returns:\n        Protobuf message corresponding to the OrderState enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType","title":"frequenz.client.electricity_trading.OrderType","text":"<p>             Bases: <code>Enum</code></p> <p>Type of the order (specifies how the order is to be executed in the market).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderType(enum.Enum):\n    \"\"\"Type of the order (specifies how the order is to be executed in the market).\"\"\"\n\n    UNSPECIFIED = electricity_trading_pb2.OrderType.ORDER_TYPE_UNSPECIFIED\n    \"\"\"The order type has not been set.\"\"\"\n\n    LIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_LIMIT\n    \"\"\"Order to buy or sell at a specific price or better.\n    It remains active until it is filled, cancelled, or expired.\"\"\"\n\n    STOP_LIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_STOP_LIMIT\n    \"\"\"An order that will be executed at a specified price,\n    or better, after a given stop price has been reached.\"\"\"\n\n    ICEBERG = electricity_trading_pb2.OrderType.ORDER_TYPE_ICEBERG\n    \"\"\"A large order divided into smaller lots to hide the actual order quantity.\n    Only the visible part of the order is shown in the order book.\"\"\"\n\n    BLOCK = electricity_trading_pb2.OrderType.ORDER_TYPE_BLOCK\n    \"\"\"User defined block order, generally a large quantity order filled all at once.\n    (Not yet supported).\"\"\"\n\n    BALANCE = electricity_trading_pb2.OrderType.ORDER_TYPE_BALANCE\n    \"\"\"Balance order aims to balance supply and demand, usually at\n    a specific location or within a system.(Not yet supported).\"\"\"\n\n    PREARRANGED = electricity_trading_pb2.OrderType.ORDER_TYPE_PREARRANGED\n    \"\"\"On exchange prearranged trade, a trade that has been privately\n    negotiated and then submitted to the exchange. (Not yet supported).\"\"\"\n\n    PRIVATE = electricity_trading_pb2.OrderType.ORDER_TYPE_PRIVATE\n    \"\"\"Private and confidential trade, not visible in the public\n    order book and has no market impact. (Not yet supported).\"\"\"\n\n    @classmethod\n    def from_pb(cls, order_type: electricity_trading_pb2.OrderType.ValueType) -&gt; Self:\n        \"\"\"Convert a protobuf OrderType value to OrderType enum.\n\n        Args:\n            order_type: Order type to convert.\n\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\n        if not any(e.value == order_type for e in cls):\n            _logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\n            return cls.UNSPECIFIED\n\n        return cls(order_type)\n\n    def to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n        \"\"\"Convert an OrderType enum to protobuf OrderType value.\n\n        Returns:\n            Protobuf message corresponding to the OrderType enum.\n        \"\"\"\n        return self.value\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BALANCE","title":"BALANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BALANCE = ORDER_TYPE_BALANCE\n</code></pre> <p>Balance order aims to balance supply and demand, usually at a specific location or within a system.(Not yet supported).</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BLOCK","title":"BLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCK = ORDER_TYPE_BLOCK\n</code></pre> <p>User defined block order, generally a large quantity order filled all at once. (Not yet supported).</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.ICEBERG","title":"ICEBERG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICEBERG = ORDER_TYPE_ICEBERG\n</code></pre> <p>A large order divided into smaller lots to hide the actual order quantity. Only the visible part of the order is shown in the order book.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.LIMIT","title":"LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT = ORDER_TYPE_LIMIT\n</code></pre> <p>Order to buy or sell at a specific price or better. It remains active until it is filled, cancelled, or expired.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PREARRANGED","title":"PREARRANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREARRANGED = ORDER_TYPE_PREARRANGED\n</code></pre> <p>On exchange prearranged trade, a trade that has been privately negotiated and then submitted to the exchange. (Not yet supported).</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PRIVATE","title":"PRIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIVATE = ORDER_TYPE_PRIVATE\n</code></pre> <p>Private and confidential trade, not visible in the public order book and has no market impact. (Not yet supported).</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.STOP_LIMIT","title":"STOP_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LIMIT = ORDER_TYPE_STOP_LIMIT\n</code></pre> <p>An order that will be executed at a specified price, or better, after a given stop price has been reached.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_TYPE_UNSPECIFIED\n</code></pre> <p>The order type has not been set.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_type: ValueType) -&gt; Self\n</code></pre> <p>Convert a protobuf OrderType value to OrderType enum.</p> PARAMETER  DESCRIPTION <code>order_type</code> <p>Order type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order_type: electricity_trading_pb2.OrderType.ValueType) -&gt; Self:\n    \"\"\"Convert a protobuf OrderType value to OrderType enum.\n\n    Args:\n        order_type: Order type to convert.\n\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\n    if not any(e.value == order_type for e in cls):\n        _logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\n        return cls.UNSPECIFIED\n\n    return cls(order_type)\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderType enum to protobuf OrderType value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderType enum.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n    \"\"\"Convert an OrderType enum to protobuf OrderType value.\n\n    Returns:\n        Protobuf message corresponding to the OrderType enum.\n    \"\"\"\n    return self.value\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams","title":"frequenz.client.electricity_trading.PaginationParams  <code>dataclass</code>","text":"<p>Parameters for paginating list requests.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PaginationParams:\n    \"\"\"Parameters for paginating list requests.\"\"\"\n\n    page_size: int | None = None\n    \"\"\"The maximum number of results to be returned per request.\"\"\"\n\n    page_token: str | None = None\n    \"\"\"The token identifying a specific page of the list results.\"\"\"\n\n    @classmethod\n    def from_pb(cls, pagination_params: pagination_params_pb2.PaginationParams) -&gt; Self:\n        \"\"\"Convert a protobuf PaginationParams to PaginationParams object.\n\n        Args:\n            pagination_params: PaginationParams to convert.\n\n        Returns:\n            PaginationParams object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            page_size=pagination_params.page_size,\n            page_token=pagination_params.page_token,\n        )\n\n    def to_pb(self) -&gt; pagination_params_pb2.PaginationParams:\n        \"\"\"Convert a PaginationParams object to protobuf PaginationParams.\n\n        Returns:\n            Protobuf message corresponding to the PaginationParams object.\n        \"\"\"\n        return pagination_params_pb2.PaginationParams(\n            page_size=self.page_size,\n            page_token=self.page_token,\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.page_size","title":"page_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_size: int | None = None\n</code></pre> <p>The maximum number of results to be returned per request.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.page_token","title":"page_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_token: str | None = None\n</code></pre> <p>The token identifying a specific page of the list results.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(pagination_params: PaginationParams) -&gt; Self\n</code></pre> <p>Convert a protobuf PaginationParams to PaginationParams object.</p> PARAMETER  DESCRIPTION <code>pagination_params</code> <p>PaginationParams to convert.</p> <p> TYPE: <code>PaginationParams</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PaginationParams object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, pagination_params: pagination_params_pb2.PaginationParams) -&gt; Self:\n    \"\"\"Convert a protobuf PaginationParams to PaginationParams object.\n\n    Args:\n        pagination_params: PaginationParams to convert.\n\n    Returns:\n        PaginationParams object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        page_size=pagination_params.page_size,\n        page_token=pagination_params.page_token,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PaginationParams\n</code></pre> <p>Convert a PaginationParams object to protobuf PaginationParams.</p> RETURNS DESCRIPTION <code>PaginationParams</code> <p>Protobuf message corresponding to the PaginationParams object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; pagination_params_pb2.PaginationParams:\n    \"\"\"Convert a PaginationParams object to protobuf PaginationParams.\n\n    Returns:\n        Protobuf message corresponding to the PaginationParams object.\n    \"\"\"\n    return pagination_params_pb2.PaginationParams(\n        page_size=self.page_size,\n        page_token=self.page_token,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price","title":"frequenz.client.electricity_trading.Price  <code>dataclass</code>","text":"<p>Price of an order.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Price:\n    \"\"\"Price of an order.\"\"\"\n\n    amount: Decimal\n    \"\"\"Amount of the price.\"\"\"\n\n    currency: Currency\n    \"\"\"Currency of the price.\"\"\"\n\n    @classmethod\n    def from_pb(cls, price: price_pb2.Price) -&gt; Self:\n        \"\"\"Convert a protobuf Price to Price object.\n\n        Args:\n            price: Price to convert.\n\n        Returns:\n            Price object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            amount=Decimal(price.amount.value),\n            currency=Currency.from_pb(price.currency),\n        )\n\n    def to_pb(self) -&gt; price_pb2.Price:\n        \"\"\"Convert a Price object to protobuf Price.\n\n        Returns:\n            Protobuf message corresponding to the Price object.\n        \"\"\"\n        decimal_amount = decimal_pb2.Decimal()\n        decimal_amount.value = str(self.amount)\n        return price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.amount","title":"amount  <code>instance-attribute</code>","text":"<pre><code>amount: Decimal\n</code></pre> <p>Amount of the price.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.currency","title":"currency  <code>instance-attribute</code>","text":"<pre><code>currency: Currency\n</code></pre> <p>Currency of the price.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(price: Price) -&gt; Self\n</code></pre> <p>Convert a protobuf Price to Price object.</p> PARAMETER  DESCRIPTION <code>price</code> <p>Price to convert.</p> <p> TYPE: <code>Price</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Price object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, price: price_pb2.Price) -&gt; Self:\n    \"\"\"Convert a protobuf Price to Price object.\n\n    Args:\n        price: Price to convert.\n\n    Returns:\n        Price object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        amount=Decimal(price.amount.value),\n        currency=Currency.from_pb(price.currency),\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Price\n</code></pre> <p>Convert a Price object to protobuf Price.</p> RETURNS DESCRIPTION <code>Price</code> <p>Protobuf message corresponding to the Price object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price:\n    \"\"\"Convert a Price object to protobuf Price.\n\n    Returns:\n        Protobuf message corresponding to the Price object.\n    \"\"\"\n    decimal_amount = decimal_pb2.Decimal()\n    decimal_amount.value = str(self.amount)\n    return price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade","title":"frequenz.client.electricity_trading.PublicTrade  <code>dataclass</code>","text":"<p>Represents a public order in the market.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PublicTrade:  # pylint: disable=too-many-instance-attributes\n    \"\"\"Represents a public order in the market.\"\"\"\n\n    public_trade_id: int\n    \"\"\"ID of the order from the public order book.\"\"\"\n\n    buy_delivery_area: DeliveryArea\n    \"\"\"Delivery area code of the buy side.\"\"\"\n\n    sell_delivery_area: DeliveryArea\n    \"\"\"Delivery area code of the sell side.\"\"\"\n\n    delivery_period: DeliveryPeriod\n    \"\"\"The delivery period for the contract.\"\"\"\n\n    modification_time: datetime\n    \"\"\"UTC Timestamp of the last order update or matching.\"\"\"\n\n    price: Price\n    \"\"\"The limit price at which the contract is to be traded.\"\"\"\n\n    quantity: Energy\n    \"\"\"The quantity of the contract being traded.\"\"\"\n\n    state: OrderState\n    \"\"\"State of the order.\"\"\"\n\n    @classmethod\n    def from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n        \"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n\n        Args:\n            public_trade: PublicTrade to convert.\n\n        Returns:\n            PublicTrade object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            public_trade_id=public_trade.id,\n            buy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\n            sell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\n            delivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\n            modification_time=public_trade.modification_time.ToDatetime(),\n            price=Price.from_pb(public_trade.price),\n            quantity=Energy.from_pb(public_trade.quantity),\n            state=OrderState.from_pb(public_trade.state),\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.buy_delivery_area","title":"buy_delivery_area  <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the buy side.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.modification_time","title":"modification_time  <code>instance-attribute</code>","text":"<pre><code>modification_time: datetime\n</code></pre> <p>UTC Timestamp of the last order update or matching.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.public_trade_id","title":"public_trade_id  <code>instance-attribute</code>","text":"<pre><code>public_trade_id: int\n</code></pre> <p>ID of the order from the public order book.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.sell_delivery_area","title":"sell_delivery_area  <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the sell side.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: OrderState\n</code></pre> <p>State of the order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade: PublicTrade) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTrade to PublicTrade object.</p> PARAMETER  DESCRIPTION <code>public_trade</code> <p>PublicTrade to convert.</p> <p> TYPE: <code>PublicTrade</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTrade object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n    \"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n\n    Args:\n        public_trade: PublicTrade to convert.\n\n    Returns:\n        PublicTrade object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        public_trade_id=public_trade.id,\n        buy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\n        sell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\n        delivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\n        modification_time=public_trade.modification_time.ToDatetime(),\n        price=Price.from_pb(public_trade.price),\n        quantity=Energy.from_pb(public_trade.quantity),\n        state=OrderState.from_pb(public_trade.state),\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter","title":"frequenz.client.electricity_trading.PublicTradeFilter  <code>dataclass</code>","text":"<p>Parameters for filtering the historic, publicly executed orders (trades).</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PublicTradeFilter:\n    \"\"\"Parameters for filtering the historic, publicly executed orders (trades).\"\"\"\n\n    states: list[OrderState] | None\n    \"\"\"List of order states to filter for.\"\"\"\n\n    delivery_period: DeliveryPeriod | None\n    \"\"\"Delivery period to filter for.\"\"\"\n\n    buy_delivery_area: DeliveryArea | None\n    \"\"\"Delivery area to filter for on the buy side.\"\"\"\n\n    sell_delivery_area: DeliveryArea | None\n    \"\"\"Delivery area to filter for on the sell side.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n\n        Args:\n            public_trade_filter: PublicTradeFilter to convert.\n\n        Returns:\n            PublicTradeFilter object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            states=[OrderState.from_pb(state) for state in public_trade_filter.states],\n            delivery_period=DeliveryPeriod.from_pb(public_trade_filter.delivery_period),\n            buy_delivery_area=DeliveryArea.from_pb(\n                public_trade_filter.buy_delivery_area\n            ),\n            sell_delivery_area=DeliveryArea.from_pb(\n                public_trade_filter.sell_delivery_area\n            ),\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n        \"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n\n        Returns:\n            Protobuf PublicTradeFilter corresponding to the object.\n        \"\"\"\n        return electricity_trading_pb2.PublicTradeFilter(\n            states=[\n                electricity_trading_pb2.OrderState.ValueType(state.value)\n                for state in self.states\n            ]\n            if self.states\n            else None,\n            delivery_period=self.delivery_period.to_pb()\n            if self.delivery_period\n            else None,\n            buy_delivery_area=self.buy_delivery_area.to_pb()\n            if self.buy_delivery_area\n            else None,\n            sell_delivery_area=self.sell_delivery_area.to_pb()\n            if self.sell_delivery_area\n            else None,\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.buy_delivery_area","title":"buy_delivery_area  <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea | None\n</code></pre> <p>Delivery area to filter for on the buy side.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.sell_delivery_area","title":"sell_delivery_area  <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea | None\n</code></pre> <p>Delivery area to filter for on the sell side.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.states","title":"states  <code>instance-attribute</code>","text":"<pre><code>states: list[OrderState] | None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade_filter: PublicTradeFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTradeFilter to PublicTradeFilter object.</p> PARAMETER  DESCRIPTION <code>public_trade_filter</code> <p>PublicTradeFilter to convert.</p> <p> TYPE: <code>PublicTradeFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTradeFilter object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n) -&gt; Self:\n    \"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n\n    Args:\n        public_trade_filter: PublicTradeFilter to convert.\n\n    Returns:\n        PublicTradeFilter object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        states=[OrderState.from_pb(state) for state in public_trade_filter.states],\n        delivery_period=DeliveryPeriod.from_pb(public_trade_filter.delivery_period),\n        buy_delivery_area=DeliveryArea.from_pb(\n            public_trade_filter.buy_delivery_area\n        ),\n        sell_delivery_area=DeliveryArea.from_pb(\n            public_trade_filter.sell_delivery_area\n        ),\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PublicTradeFilter\n</code></pre> <p>Convert a PublicTradeFilter object to protobuf PublicTradeFilter.</p> RETURNS DESCRIPTION <code>PublicTradeFilter</code> <p>Protobuf PublicTradeFilter corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n    \"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n\n    Returns:\n        Protobuf PublicTradeFilter corresponding to the object.\n    \"\"\"\n    return electricity_trading_pb2.PublicTradeFilter(\n        states=[\n            electricity_trading_pb2.OrderState.ValueType(state.value)\n            for state in self.states\n        ]\n        if self.states\n        else None,\n        delivery_period=self.delivery_period.to_pb()\n        if self.delivery_period\n        else None,\n        buy_delivery_area=self.buy_delivery_area.to_pb()\n        if self.buy_delivery_area\n        else None,\n        sell_delivery_area=self.sell_delivery_area.to_pb()\n        if self.sell_delivery_area\n        else None,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder","title":"frequenz.client.electricity_trading.UpdateOrder  <code>dataclass</code>","text":"<p>Represents the order properties that can be updated after an order has been placed.</p> <p>At least one of the optional fields must be set for an update to take place.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass UpdateOrder:  # pylint: disable=too-many-instance-attributes\n    \"\"\"\n    Represents the order properties that can be updated after an order has been placed.\n\n    At least one of the optional fields must be set for an update to take place.\n    \"\"\"\n\n    price: Price | None\n    \"\"\"The updated limit price at which the contract is to be traded.\n    This is the maximum price for a BUY order or the minimum price for a SELL order.\"\"\"\n\n    quantity: Energy | None\n    \"\"\"The updated quantity of the contract being traded, specified in MWh.\"\"\"\n\n    stop_price: Price | None\n    \"\"\"Applicable for STOP_LIMIT orders. This is the updated stop price that triggers\n    the limit order.\"\"\"\n\n    peak_price_delta: Price | None\n    \"\"\"Applicable for ICEBERG orders. This is the updated price difference\n    between the peak price and the limit price.\"\"\"\n\n    display_quantity: Energy | None\n    \"\"\"Applicable for ICEBERG orders. This is the updated quantity of the order\n    to be displayed in the order book.\"\"\"\n\n    execution_option: OrderExecutionOption | None\n    \"\"\"Updated execution options such as All or None, Fill or Kill, etc.\"\"\"\n\n    valid_until: datetime | None\n    \"\"\"This is an updated timestamp defining the time after which the order should\n    be cancelled if not filled. The timestamp is in UTC.\"\"\"\n\n    payload: dict[str, struct_pb2.Value] | None\n    \"\"\"Updated user-defined payload individual to a specific order. This can be any data\n    that the user wants to associate with the order.\"\"\"\n\n    tag: str | None\n    \"\"\"Updated user-defined tag to group related orders.\"\"\"\n\n    @classmethod\n    def from_pb(\n        cls,\n        update_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n    ) -&gt; Self:\n        \"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n\n        Args:\n            update_order: UpdateOrder to convert.\n\n        Returns:\n            UpdateOrder object corresponding to the protobuf message.\n        \"\"\"\n        return cls(\n            price=Price.from_pb(update_order.price)\n            if update_order.HasField(\"price\")\n            else None,\n            quantity=Energy.from_pb(update_order.quantity)\n            if update_order.HasField(\"quantity\")\n            else None,\n            stop_price=Price.from_pb(update_order.stop_price)\n            if update_order.HasField(\"stop_price\")\n            else None,\n            peak_price_delta=Price.from_pb(update_order.peak_price_delta)\n            if update_order.HasField(\"peak_price_delta\")\n            else None,\n            display_quantity=Energy.from_pb(update_order.display_quantity)\n            if update_order.HasField(\"display_quantity\")\n            else None,\n            execution_option=OrderExecutionOption.from_pb(update_order.execution_option)\n            if update_order.HasField(\"execution_option\")\n            else None,\n            valid_until=update_order.valid_until.ToDatetime()\n            if update_order.HasField(\"valid_until\")\n            else None,\n            payload=json_format.MessageToDict(update_order.payload)\n            if update_order.payload\n            else None,\n            tag=update_order.tag if update_order.HasField(\"tag\") else None,\n        )\n\n    def to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n        \"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n\n        Returns:\n            Protobuf UpdateOrder corresponding to the object.\n        \"\"\"\n        if self.valid_until:\n            valid_until = timestamp_pb2.Timestamp()\n            valid_until.FromDatetime(self.valid_until)\n        else:\n            valid_until = None\n        return electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\n            price=self.price.to_pb() if self.price else None,\n            quantity=self.quantity.to_pb() if self.quantity else None,\n            stop_price=self.stop_price.to_pb() if self.stop_price else None,\n            peak_price_delta=self.peak_price_delta.to_pb()\n            if self.peak_price_delta\n            else None,\n            display_quantity=self.display_quantity.to_pb()\n            if self.display_quantity\n            else None,\n            execution_option=(\n                electricity_trading_pb2.OrderExecutionOption.ValueType(\n                    self.execution_option.value\n                )\n                if self.execution_option\n                else None\n            ),\n            valid_until=valid_until if self.valid_until else None,\n            payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n            tag=self.tag if self.tag else None,\n        )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-attributes","title":"Attributes","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.display_quantity","title":"display_quantity  <code>instance-attribute</code>","text":"<pre><code>display_quantity: Energy | None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.execution_option","title":"execution_option  <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None\n</code></pre> <p>Updated execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None\n</code></pre> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.peak_price_delta","title":"peak_price_delta  <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price | None\n</code></pre> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy | None\n</code></pre> <p>The updated quantity of the contract being traded, specified in MWh.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.stop_price","title":"stop_price  <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None\n</code></pre> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str | None\n</code></pre> <p>Updated user-defined tag to group related orders.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.valid_until","title":"valid_until  <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None\n</code></pre> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-functions","title":"Functions","text":""},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(update_order: UpdateOrder) -&gt; Self\n</code></pre> <p>Convert a protobuf UpdateOrder to UpdateOrder object.</p> PARAMETER  DESCRIPTION <code>update_order</code> <p>UpdateOrder to convert.</p> <p> TYPE: <code>UpdateOrder</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>UpdateOrder object corresponding to the protobuf message.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\n    cls,\n    update_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n) -&gt; Self:\n    \"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n\n    Args:\n        update_order: UpdateOrder to convert.\n\n    Returns:\n        UpdateOrder object corresponding to the protobuf message.\n    \"\"\"\n    return cls(\n        price=Price.from_pb(update_order.price)\n        if update_order.HasField(\"price\")\n        else None,\n        quantity=Energy.from_pb(update_order.quantity)\n        if update_order.HasField(\"quantity\")\n        else None,\n        stop_price=Price.from_pb(update_order.stop_price)\n        if update_order.HasField(\"stop_price\")\n        else None,\n        peak_price_delta=Price.from_pb(update_order.peak_price_delta)\n        if update_order.HasField(\"peak_price_delta\")\n        else None,\n        display_quantity=Energy.from_pb(update_order.display_quantity)\n        if update_order.HasField(\"display_quantity\")\n        else None,\n        execution_option=OrderExecutionOption.from_pb(update_order.execution_option)\n        if update_order.HasField(\"execution_option\")\n        else None,\n        valid_until=update_order.valid_until.ToDatetime()\n        if update_order.HasField(\"valid_until\")\n        else None,\n        payload=json_format.MessageToDict(update_order.payload)\n        if update_order.payload\n        else None,\n        tag=update_order.tag if update_order.HasField(\"tag\") else None,\n    )\n</code></pre>"},{"location":"python-reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; UpdateOrder\n</code></pre> <p>Convert a UpdateOrder object to protobuf UpdateOrder.</p> RETURNS DESCRIPTION <code>UpdateOrder</code> <p>Protobuf UpdateOrder corresponding to the object.</p> Source code in <code>frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n    \"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n\n    Returns:\n        Protobuf UpdateOrder corresponding to the object.\n    \"\"\"\n    if self.valid_until:\n        valid_until = timestamp_pb2.Timestamp()\n        valid_until.FromDatetime(self.valid_until)\n    else:\n        valid_until = None\n    return electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\n        price=self.price.to_pb() if self.price else None,\n        quantity=self.quantity.to_pb() if self.quantity else None,\n        stop_price=self.stop_price.to_pb() if self.stop_price else None,\n        peak_price_delta=self.peak_price_delta.to_pb()\n        if self.peak_price_delta\n        else None,\n        display_quantity=self.display_quantity.to_pb()\n        if self.display_quantity\n        else None,\n        execution_option=(\n            electricity_trading_pb2.OrderExecutionOption.ValueType(\n                self.execution_option.value\n            )\n            if self.execution_option\n            else None\n        ),\n        valid_until=valid_until if self.valid_until else None,\n        payload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\n        tag=self.tag if self.tag else None,\n    )\n</code></pre>"}]}